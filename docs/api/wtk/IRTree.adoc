[#api_IRTree]
= IR Tree API
:toc:
:source-highlighter: pygments
:source-language: c++
:source_subs: attributes,specialchars,macros
ifndef::xref-rel-dir[]
:xref-rel-dir: ../../
endif::[]

Include this API as

----
#include <wtk/IRTree.h>
----

Members of this API live in the following namespace

----
namespace wtk { ...
----

The IR Tree API is parameterized on a `Number_T` template.
`Number_T` should be integer-like enough to be parsed from a string.
This API is abstract and implemented by parsers for various IR formats.
As an abstract interface many "attributes" must be accessed through accessor methods due to different storage methods of various IR formats.

At a top level, the xref:#struct_IRTree[`wtk::IRTree<Number_T>`] is the root of an abstract syntax tree for a _relation_ in the SIEVE IR.
The xref:#struct_DirectiveList[`wtk::DirectiveList<Number_T>`] defines scope block within the AST and other structs such as xref:#struct_BinaryGate[`wtk::BinaryGate`] defining individual directives.

Pointer members provided by the IR Tree API may be expected to be nonnull, taking the lifetime of the xref:{xref-rel-dir}api/wtk/Parser.adoc#api_Parser[parser] which provided a top-level xref:#struct_IRTree[`wtk::IRTree<Number_T>*`].
However, as defined by the parser, the `wtk::IRTree<Number_T>*` may itself be null.
The parser retains ownership of all objects from this API, the caller may not `free(...)` them.

[#struct_IRTree]
== `template<typename Number_T> struct IRTree`
The `wtk::IRTree<Number_T>` struct is the root of an IR syntax tree.
The encapsulates both a list of named functions and the top-level scope of an IR relation.

[#IRTree_size]
=== `size_t size()`
This method indicates how many named function declarations are defined by this relation.
It is an integer greater than or equal to `0`.

----
virtual size_t size() = 0;
----

[#IRTree_functionDeclare]
=== `wtk::FunctionDeclare<Number_T>* functionDeclare(size_t n)`
Retrieve a named function declaration by index.
`n` must be between `0` (inclusive) and `this->size()` (exclusive) or else undefined behavior occurs.
It returns a nonnull xref:#struct_FunctionDeclare[`wtk::FunctionDeclare<Number_T>*`].

----
virtual wtk::FunctionDeclare<Number_T>* functionDeclare(size_t n) = 0;
----

[#IRTree_body]
=== `wtk::DirectiveList<Number_T>* body()`
Retrieve the body of the relation.
It returns a nonnull xref:#struct_DirectiveList[`wtk::DirectiveList<Number_T>*`].

----
virtual wtk::DirectiveList<Number_T>* body() = 0;
----

[#IRTree_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the IRTree begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_DirectiveList]
== `template<typename Number_T> struct DirectiveList`
The `wtk::DirectiveList<Number_T>` is a list type for directives.
Since directives must be differentiated, each index of the list has a tag indicating a type, through which the element must be retrieved.

[#DirectiveList_size]
=== `size_t size()`
Indicates the number of elements in the list.

----
virtual size_t size() = 0;
----

[#DirectiveList_enum_Type]
=== `enum Type`
This enumerates the various types which an element may take.

`wtk::DirectiveList<Number_T>::BINARY_GATE`:: corresponds to xref:#struct_BinaryGate[`wtk::BinaryGate`] and xref:#DirectiveList_binaryGate[`this->binaryGate(n)`].
`wtk::DirectiveList<Number_T>::UNARY_GATE`:: corresponds to xref:#struct_UnaryGate[`wtk::UnaryGate`] and xref:#DirectiveList_unaryGate[`this->unaryGate(n)`].
`wtk::DirectiveList<Number_T>::BINARY_CONST_GATE`:: corresponds to xref:#struct_BinaryConstGate[`wtk::BinaryConstGate<Number_T>`] and xref:#DirectiveList_binaryConstGate[`this->binaryConstGate(n)`].
`wtk::DirectiveList<Number_T>::INPUT`:: corresponds to xref:#struct_Input[`wtk::Input`] and xref:#DirectiveList_input[`this->input(n)`].
`wtk::DirectiveList<Number_T>::ASSIGN`:: corresponds to xref:#struct_Assign[`wtk::Assign<Number_T>`] and xref:#DirectiveList_assign[`this->assign(n)`].
`wtk::DirectiveList<Number_T>::ASSERT_ZERO`:: corresponds to xref:#struct_Terminal[a `wtk::Terminal` when used for the `@assert_zero` gate] and xref:#DirectiveList_assertZero[`this->assertZero(n)`].

`wtk::DirectiveList<Number_T>::DELETE_SINGLE`:: corresponds to xref:#struct_Terminal[a `wtk::Terminal` when used for a `@delete` directive] and xref:#DirectiveList_deleteSingle[`this->deleteSingle(n)`].
`wtk::DirectiveList<Number_T>::DELETE_RANGE`:: corresponds to xref:#struct_WireRange[an `wtk::WireRange` when used for a `@delete` directive] and xref:#DirectiveList_deleteRange[`this->deleteRange(n)`].
`wtk::DirectiveList<Number_T>::FUNCTION_INVOKE`:: corresponds to xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`] and xref:#DirectiveList_functionInvoke[`this->functionInvoke(n)`].
`wtk::DirectiveList<Number_T>::ANON_FUNCTION`:: corresponds to xref:#struct_AnonFunction[`wtk::AnonFunction<Number_T>`] and xref:#DirectiveList_anonFunction[`this->anonFunction(n)`].
`wtk::DirectiveList<Number_T>::FOR_LOOP`:: corresponds to xref:#struct_ForLoop[`wtk::ForLoop<Number_T>`] and xref:#DirectiveList_forLoop[`this->forLoop(n)`].
`wtk::DirectiveList<Number_T>::SWITCH_STATEMENT`:: corresponds to xref:#struct_SwitchStatement[`wtk::SwitchStatement<Number_T>`] and xref:#DirectiveList_switchStatement[`this->switchStatement(n)`].

[#DirectiveList_type]
=== `wtk::DirectiveList<Number_T>::Type type(size_t n)`
Returns the xref:#DirectiveList_enum_Type[type] of the nth element in this list.
`n` must be in the range `n >= 0 && n < this->size()` otherwise undefined behavior occurs.

----
virtual Type type(size_t n) = 0;
----

[#DirectiveList_binaryGate]
=== `wtk::BinaryGate* binaryGate(size_t n)`
Returns the nth element as a xref:#struct_BinaryGate[`wtk::BinaryGate`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::BINARY_GATE]` otherwise undefined behavior occurs.

----
virtual wtk::BinaryGate* binaryGate(size_t n) = 0;
----

[#DirectiveList_unaryGate]
=== `wtk::UnaryGate* unaryGate(size_t n)`
Returns the nth element as a xref:#struct_UnaryGate[`wtk::UnaryGate`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::UNARY_GATE]` otherwise undefined behavior occurs.

----
virtual wtk::UnaryGate* unaryGate(size_t n) = 0;
----

[#DirectiveList_binaryConstGate]
=== `wtk::BinaryConstGate<Number_T>* binaryConstGate(size_t n)`
Returns the nth element as a xref:#struct_BinaryConstGate[`wtk::BinaryConstGate<Number_T>`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::BINARY_CONST_GATE]` otherwise undefined behavior occurs.

----
virtual wtk::BinaryConstGate<Number_T>* binaryConstGate(size_t n) = 0;
----

[#DirectiveList_input]
=== `wtk::Input* input(size_t n)`
Returns the nth element as a xref:#struct_Input[`wtk::Input`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::INPUT]` otherwise undefined behavior occurs.

----
virtual wtk::Input* input(size_t n) = 0;
----

[#DirectiveList_assign]
=== `wtk::Assign<Number_T>* assign(size_t n)`
Returns the nth element as a xref:#struct_Assign[`wtk::Assign<Number_T>`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::ASSIGN]` otherwise undefined behavior occurs.

----
virtual wtk::Assign<Number_T>* assign(size_t n) = 0;
----

[#DirectiveList_assertZero]
=== `wtk::Terminal* assertZero(size_t n)`
Returns the nth element as a xref:#struct_Terminal[`wtk::Terminal`] type for the purpose of an `@assert_zero` gate.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::ASSERT_ZERO]` otherwise undefined behavior occurs.

----
virtual wtk::Terminal* assertZero(size_t n) = 0;
----

[#DirectiveList_deleteSingle]
=== `wtk::Terminal* deleteSingle(size_t n)`
Returns the nth element as a xref:#struct_Terminal[`wtk::Terminal`] type for the purpose of a `@delete` gate.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::DELETE_SINGLE]` otherwise undefined behavior occurs.

----
virtual wtk::Terminal* deleteSingle(size_t n) = 0;
----

[#DirectiveList_deleteRange]
=== `wtk::WireRange* deleteRange(size_t n)`
Returns the nth element as a xref:#struct_WireRange[`wtk::WireRange`] type for the purpose of a `@delete` gate.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::DELETE_RANGE]` otherwise undefined behavior occurs.

----
virtual wtk::WireRange* deleteRange(size_t n) = 0;
----

[#DirectiveList_functionInvoke]
=== `wtk::FunctionInvoke* functionInvoke(size_t n)`
Returns the nth element as a xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::FUNCTION_INVOKE]` otherwise undefined behavior occurs.

----
virtual wtk::FunctionInvoke* functionInvoke(size_t n) = 0;
----

[#DirectiveList_anonFunction]
=== `wtk::AnonFunction<Number_T>* anonFunction(size_t n)`
Returns the nth element as a xref:#struct_AnonFunction[`wtk::AnonFunction<Number_T>`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::ANON_FUNCTION]` otherwise undefined behavior occurs.

----
virtual wtk::AnonFunction<Number_T>* anonFunction(size_t n) = 0;
----

[#DirectiveList_forLoop]
=== `wtk::ForLoop<Number_T>* forLoop(size_t n)`
Returns the nth element as a xref:#struct_ForLoop[`wtk::ForLoop<Number_T>`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::FOR_LOOP]` otherwise undefined behavior occurs.

----
virtual wtk::ForLoop<Number_T>* forLoop(size_t n) = 0;
----

[#DirectiveList_switchStatement]
=== `wtk::SwitchStatement<Number_T>* switchStatement(size_t n)`
Returns the nth element as a xref:#struct_SwitchhStatement[`wtk::SwitchStatement<Number_T>`] type.
`n` must be in the range `n >= 0 && n < xref:#DirectiveList_size[this->size()]` and `n` must have the type `xref:#DirectiveList_type[this->type(n)] == xref:#DirectiveList_enum_Type[wtk::DirectiveList<Number_T>::SWITCH_STATEMENT]` otherwise undefined behavior occurs.

----
virtual wtk::SwitchStatement<Number_T>* switchStatement(size_t n) = 0;
----

[#DirectiveList_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the DirectiveList begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_BinaryGate]
== `struct BinaryGate`
This represents a binary gate in the IR. Binary refers to the two-input wires of this gate, not numeric representation.
It has methods for left and right input wires as well as the output wire.
The specific gate type is the xref:#BinaryGate_enum_Calculation[`Calculation`] enum.

[#BinaryGate_enum_Calculation]
=== `enum Calculation`
Indicates what calculation this gate performs.

`wtk::BinaryGate::AND`:: `@and`
`wtk::BinaryGate::XOR`:: `@xor`
`wtk::BinaryGate::ADD`:: `@add`
`wtk::BinaryGate::MUL`:: `@mul`

[#BinaryGate_calculation]
=== `wtk::BinaryGate::Calculation calculation()`
returns which calculation the binary gate performs.

----
virtual Calculation calculation() = 0;
----

[#BinaryGate_outputWire]
=== `wtk::index_t outputWire()`
Returns the gate's output wire.

----
virtual wtk::index_t outputWire() = 0;
----

[#BinaryGate_leftWire]
=== `wtk::index_t leftWire()`
Returns the gate's left input wire.

----
virtual wtk::index_t leftWire() = 0;
----

[#BinaryGate_rightWire]
=== `wtk::index_t rightWire()`
Returns the gate's right input wire.

----
virtual wtk::index_t rightWire() = 0;
----

[#BinaryGate_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the binary gate begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_UnaryGate]
== `struct UnaryGate`
This represents a unary gate in the IR. Unary refers to the single input wire of this gate, not numeric representation.
It has methods for the input wire as well as the output wire.
The specific gate type is the xref:#UnaryGate_enum_Calculation[`Calculation`] enum.

[#UnaryGate_enum_Calculation]
=== `enum Calculation`
Indicates what calculation this gate performs.

`wtk::UnaryGate::NOT`:: `$0 <- @not($1)`
`wtk::UnaryGate::COPY`:: `$0 <- $1`

[#UnaryGate_calculation]
=== `wtk::UnaryGate::Calculation calculation()`
returns which calculation the unary gate performs.

----
virtual Calculation calculation() = 0;
----

[#UnaryGate_outputWire]
=== `wtk::index_t outputWire()`
Returns the gate's output wire.

----
virtual wtk::index_t outputWire() = 0;
----

[#UnaryGate_inputWire]
=== `wtk::index_t rightWire()`
Returns the gate's input wire.

----
virtual wtk::index_t inputWire() = 0;
----

[#UnaryGate_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the unary gate begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_BinaryConstGate]
== `template<typename Number_T> struct BinaryConstGate`
This represents a binary constant gate in the IR. Binary refers to the input wire and input constant of this gate, not numeric representation.
It has methods for left input wire and right input constant as well as the output wire.
The specific gate type is the xref:#BinaryConstGate_enum_Calculation[`Calculation`] enum.

[#BinaryConstGate_enum_Calculation]
=== `enum Calculation`
Indicates what calculation this gate performs.

`wtk::BinaryConstGate<Number_T>::ADDC`:: `@addc`
`wtk::BinaryConstGate<Number_T>::MULC`:: `@mulc`

[#BinaryConstGate_calculation]
=== `wtk::BinaryConstGate<Number_T>::Calculation calculation()`
returns which calculation the binary gate performs.

----
virtual Calculation calculation() = 0;
----

[#BinaryConstGate_outputWire]
=== `wtk::index_t outputWire()`
Returns the gate's output wire.

----
virtual wtk::index_t outputWire() = 0;
----

[#BinaryConstGate_leftWire]
=== `wtk::index_t leftWire()`
Returns the gate's left input wire.

----
virtual wtk::index_t leftWire() = 0;
----

[#BinaryConstGate_rightWire]
=== `wtk::index_t rightWire()`
Returns the gate's right input constant.

----
virtual Number_T rightValue() = 0;
----

[#BinaryConstGate_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the binary constant gate begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_Input]
== `struct Input`
Represents an input directive (either `@instance` or `@short_witness`).
the xref:#Input_enum_Stream[`Stream`] enumeration indicates from which stream to consume.

[#Input_enum_Stream]
=== `enum Stream`
An enumeration of the IR stream resources.

`wtk::Input::INSTANCE`:: `@instance`
`wtk::Input::SHORT_WITNESS`:: `@short_witness`

[#Input_stream]
=== `wtk::Input::Stream stream()`
Returns the xref:#Input_enum_Stream[stream] from which this directive is to consume.

----
virtual Stream stream() = 0;
----

[#Input_outputWire]
=== `wtk::index_t outputWire()`
Returns the stream consumption's output wire.

----
virtual wtk::index_t outputWire() = 0;
----

[#Input_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the input directive begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_Assign]
== `template<typename Number_T> struct Assign`
A directive that assigns a constant value to an output wire.

[#Assign_outputWire]
=== `wtk::index_t outputWire()`
Returns the assign directive's output wire.

----
virtual wtk::index_t outputWire() = 0;
----

[#Assign_constValue]
=== `Number_T constValue()`
Returns the assign directive's constant input value.

----
virtual Number_T constValue() = 0;
----

[#Assign_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the assign directive begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_Terminal]
== `struct Terminal`
Represents a directive with just a single input wire.
Its name is derived from the fact that it has no output wires, thus "terminating" some sequence of gates.
It is used by the directives `@assert_zero` and `@delete` (for a single input wire), although they are distinguished by xref:#DirectiveList_enum_Type[`wtk::DirectiveList<Number_T>::Type`] rather than an enumeration within `struct Terminal`.

[#Terminal_wire]
=== `wtk::index_t wire()`
Returns the terminal's single input wire.

----
virtual wtk::index_t wire() = 0;
----

[#Terminal_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the terminal begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_WireRange]
== `struct WireRange`
Represents a range of wires in the IR.
It is used for the range form of the `@delete` directive, as well as a component of the xref:#struct_WireList[`wtk::WireList`].

[#WireRange_first()]
=== `wtk::index_t first()`
Returns the first wire in the range (consider it inclusive).

----
virtual wtk::index_t first() = 0;
----

[#WireRange_last()]
=== `wtk::index_t last()`
Returns the last wire in the range (consider it inclusive).

----
virtual wtk::index_t last() = 0;
----

[#WireRange_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the wire range begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_WireList]
== `struct WireList`
The IR uses wire lists for holding parameters and returns to function-gates.
These lists are "ranged" such that the elements of the list do not correspond to the length of the list.
Some elements are individual wires, whereas other elements are ranges of wires.
Element type is given by the xref:#WireList_enum_Type[`Type`] enumeration.

[#WireList_size]
=== `size_t size()`
Indicates how many _elements_ are in the list (does not necessarily correspond to _wire count_).

----
virtual size_t size() = 0;
----

[#WireList_enum_Type]
=== `enum Type`
Indicates if an element a single or a range element.

 - `wtk::WireList::SINGLE`
 - `wtk::WireList::RANGE`

[#WireList_type]
=== `wtk::WireList::Type type(size_t n)`
Returns the type of the nth element.
`n` must be in the range `n >= 0 && n < xref:#WireList_size[this->size()]` or else undefined behavior occurs.

----
virtual Type type(size_t n) = 0;
----

[#WireList_single]
=== `wtk::index_t single(size_t n)`
Returns the nth element in the list as a single element.
`n` must be in the range `n >= 0 && n < xref:#WireList_size[this->size()]` and `n` must have the type `xref:#WireList_type[this->type(n)] == xref:#WireList_enum_Type[wtk::WireList::SINGLE]` or else undefined behavior occurs.

----
virtual wtk::index_t single(size_t n) = 0;
----

[#WireList_range]
=== `wtk::WireRange* range(size_t n)`
Returns the nth element in the list as a xref:#struct_WireRange[range] element.
`n` must be in the range `n >= 0 && n < xref:#WireList_size[this->size()]` and `n` must have the type `xref:#WireList_type[this->type(n)] == xref:#WireList_enum_Type[wtk::WireList::RANGE]` or else undefined behavior occurs.

----
virtual wtk::WireRange* range(size_t n) = 0;
----

[#WireList_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the wire list begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_FunctionDeclare]
== `template<typename Number_T> struct FunctionDeclare`
This `wtk::FunctionDeclare<Number_T>` is the definition of a named function-gate.
It pairs with xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`] for invocation.
They should be matched to eachother by a name (as a `char*`).

[#FunctionDeclare_name]
=== `char const* name()`
Returns the name of the function.

----
virtual char const* name() = 0;
----

[#FunctionDeclare_outputCount]
=== `wtk::index_t outputCount()`
Returns the number of output wires this function gate expects.

----
virtual wtk::index_t outputCount() = 0;
----

[#FunctionDeclare_inputCount]
=== `wtk::index_t inputCount()`
Returns the number of input wires this function gate expects.

----
virtual wtk::index_t inputCount() = 0;
----

[#FunctionDeclare_instanceCount]
=== `wtk::index_t instanceCount()`
Returns the number of instance values this function gate will consume.

----
virtual wtk::index_t instanceCount() = 0;
----

[#FunctionDeclare_shortWitnessCount]
=== `wtk::index_t shortWitnessCount()`
Returns the number of short witness values this function gate will consume.

----
virtual wtk::index_t shortWitnessCount() = 0;
----

[#FunctionDeclare_body]
=== `wtk::DirectiveList<Number_T>* body()`
returns the body of the function gate.

----
virtual DirectiveList<Number_T>* body() = 0;
----

[#FunctionDeclare_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_FunctionInvoke]
== `struct FunctionInvoke`
The `wtk:FunctionInvoke` invokes a function gate, carrying a name which should match with the name of a xref:#struct_FunctionDeclare[`wtk::FunctionDeclare<Number_T>`].

[#FunctionInvoke_name]
=== `char const* name()`
Returns the name of the function gate.

----
virtual char const* name() = 0;
----

[#FunctionInvoke_outputList]
=== `wtk::WireList* outputList()`
Returns a xref:#struct_WireList[`wtk::WireList`] for the output wires of this invocation.

----
virtual wtk::WireList* outputList() = 0;
----

[#FunctionInvoke_inputList]
=== `wtk::WireList* inputList()`
Returns a xref:#struct_WireList[`wtk::WireList`] for the input wires of this invocation.

----
virtual wtk::WireList* inputList() = 0;
----

[#FunctionInvoke_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the function invocation begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_AnonFunction]
== `template<typename Number_T> struct AnonFunction`
The `wtk::AnonFunction<Number_T>` is the simultaneous declaration and invocation of an anonymous function-gate.
It mirrors the structure of both xref:#struct_FunctionDeclare[`wtk::FunctionDeclare<Number_T>`] and xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`], although without certain attributes such as `name()`.

[#AnonFunction_outputList]
=== `wtk::WireList* outputList()`
Returns a xref:#struct_WireList[`wtk::WireList`] for the output wires of this anonymous function.

----
virtual wtk::WireList* outputList() = 0;
----

[#AnonFunction_inputList]
=== `wtk::WireList* inputList()`
Returns a xref:#struct_WireList[`wtk::WireList`] for the input wires of this anonymous function.

----
virtual wtk::WireList* inputList() = 0;
----

[#AnonFunction_instanceCount]
=== `wtk::index_t instanceCount()`
Returns the number of instance values this anonymous function gate will consume.

----
virtual wtk::index_t instanceCount() = 0;
----

[#AnonFunction_shortWitnessCount]
=== `wtk::index_t shortWitnessCount()`
Returns the number of short witness values this anonymous function gate will consume.

----
virtual wtk::index_t shortWitnessCount() = 0;
----

[#AnonFunction_body]
=== `wtk::DirectiveList<Number_T>* body()`
returns the body of the anonymous function gate.

----
virtual DirectiveList<Number_T>* body() = 0;
----

[#AnonFunction_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the anonymous function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_IterExpr]
== `struct IterExpr`
The `wtk::IterExpr` takes the place of `wtk::index_t` in input and output lists of xref:#struct_ForLoop[For Loop] bodies.
Instead of representing an exact wire-index, these expressions evaluate to a wire-index, allowing the loop to traverse ranges of wires.

All iterator expressions are carried out over `wtk::index_t`.
The expressions are a recursive datatype, with base cases for numeric literals and loop-iterators.
Recursive cases exist for addition, subtraction, multiplication, and division by a constant.
The expression type is given by xref:#IterExpr_enum_Type[`enum Type`].

[#IterExpr_enum_Type]
=== `enum Type`
This enumerates the various types of expressions.

`wtk::IterExpr::LITERAL`:: A numeric literal
`wtk::IterExpr::ITERATOR`:: A reference to a loop iterator
`wtk::IterExpr::ADD`:: Addition expression of two sub-expressions
`wtk::IterExpr::SUB`:: Subtraction expression of two sub-expressions
`wtk::IterExpr::MUL`:: Multiplition expression of two sub-expressions
`wtk::IterExpr::DIV`:: Division expression of one sub-expression and a constant divisor

[#IterExpr_type]
=== `wtk:IterExpr::Type type()`
Returns the type of this expression.

----
virtual Type type() = 0;
----

[#IterExpr_literal]
=== `wtk::index_t literal()`
Returns this literal expression or the right-hand-side of this division expression as a `wtk::index_t`.
If the following precondition isn't met, then undefined behavior occurs (see also xref:#IterExpr_type[`this->type()`] and xref:#IterExpr_enum_Type[`enum Type`]).

----
this->type() == wtk::IterExpr::LITERAL
  || this->type() == wtk::IterExpr::DIV
----

----
virtual wtk::index_t literal() = 0;
----

[#IterExpr_name]
=== `char const* name()`
Returns this loop-iterator expression as a `char*`.
If the following precondition isn't met, then undefined behavior occurs (see also xref:#IterExpr_type[`this->type()`] and xref:#IterExpr_enum_Type[`enum Type`]).

----
this->type() == wtk::IterExpr::ITERATOR
----

----
virtual wtk::index_t literal() = 0;
----

[#IterExpr_lhs]
=== `wtk::IterExpr* lhs()`
Returns the left-hand-side of this expression.
If the following precondition isn't met, then undefined behavior occurs (see also xref:#IterExpr_type[`this->type()`] and xref:#IterExpr_enum_Type[`enum Type`]).

----
this->type() == wtk::IterExpr::ADD
  || this->type() == wtk::IterExpr::SUB
  || this->type() == wtk::IterExpr::MUL
  || this->type() == wtk::IterExpr::DIV
----

----
virtual IterExpr* lhs() = 0;
----

[#IterExpr_rhs]
=== `wtk::IterExpr* lhs()`
Returns the right-hand-side of this expression.
If the following precondition isn't met, then undefined behavior occurs (see also xref:#IterExpr_type[`this->type()`] and xref:#IterExpr_enum_Type[`enum Type`]).

----
this->type() == wtk::IterExpr::ADD
  || this->type() == wtk::IterExpr::SUB
  || this->type() == wtk::IterExpr::MUL
----

----
virtual IterExpr* lhs() = 0;
----

[#IterExpr_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the iterator expression begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_IterExprWireRange]
== `struct IterExprWireRange`
Represents a range of iterator expressions, mirroring the form of xref:#struct_WireRange[`wtk::WireRange`].
It is used as a component of the xref:#struct_IterExprWireList[`wtk::IterExprWireList`] (which itself mirrors xref:#struct_WireList[`wtk::WireList`]).

[#IterExprWireRange_first()]
=== `wtk::IterExpr* first()`
Returns a xref:#struct_IterExpr[`wtk::IterExpr`] for the first wire in the range (consider it inclusive).

----
virtual wtk::IterExpr* first() = 0;
----

[#IterExprWireRange_last()]
=== `wtk::IterExpr* last()`
Returns a xref:#struct_IterExpr[`wtk::IterExpr`] for the last wire in the range (consider it inclusive).

----
virtual wtk::IterExpr* last() = 0;
----

[#IterExprWireRange_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the wire range begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_IterExprWireList]
== `struct IterExprWireList`
Represents a list of iterator expressions, mirroring the form of xref:#struct_WireList[`wtk::WireList`].
For for-loop bodies, the input and output wire lists use these to enable traversal based on the loop iterator.

These lists are "ranged" such that the elements of the list do not correspond to the length of the list.
Some elements are individual expressions, whereas other elements are ranges of expressions.
Element type is given by the xref:#IterExprWireList_enum_Type[`Type`] enumeration.

[#IterExprWireList_size]
=== `size_t size()`
Indicates how many _elements_ are in the list (does not necessarily correspond to _wire count_).

----
virtual size_t size() = 0;
----

[#IterExprWireList_enum_Type]
=== `enum Type`
Indicates if an element a single or a range element.

 - `wtk::IterExprWireList::SINGLE`
 - `wtk::IterExprWireList::RANGE`

[#IterExprWireList_type]
=== `wtk::IterExprWireList::Type type(size_t n)`
Returns the type of the nth element.
`n` must be in the range `n >= 0 && n < xref:#IterExprWireList_size[this->size()]` or else undefined behavior occurs.

----
virtual Type type(size_t n) = 0;
----

[#IterExprWireList_single]
=== `wtk::ItereExpr* single(size_t n)`
Returns the nth element in the list as a single element.
`n` must be in the range `n >= 0 && n < xref:#IterExprWireList_size[this->size()]` and `n` must have the type `xref:#IterExprWireList_type[this->type(n)] == xref:#IterExprWireList_enum_Type[wtk::IterExprWireList::SINGLE]` or else undefined behavior occurs.

----
virtual wtk::IterExpr* single(size_t n) = 0;
----

[#IterExprWireList_range]
=== `wtk::IterExprWireRange* range(size_t n)`
Returns the nth element in the list as a xref:#struct_IterExprWireRange[range] element.
`n` must be in the range `n >= 0 && n < xref:#IterExprWireList_size[this->size()]` and `n` must have the type `xref:#IterExprWireList_type[this->type(n)] == xref:#IterExprWireList_enum_Type[wtk::IterExprWireList::RANGE]` or else undefined behavior occurs.

----
virtual wtk::WireRange* range(size_t n) = 0;
----

[#IterExprWireList_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the wire list begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_IterExprFunctionInvoke]
== `struct IterExprFunctionInvoke`
The `wtk:IterExprFunctionInvoke` invokes a function gate as the body of a for-loop, carrying a name which should match with the name of a xref:#struct_FunctionDeclare[`wtk::FunctionDeclare<Number_T>`].
It mirrors xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`] replacing input and output lists with xref:#struct_IterExprWireList[`wtk::IterExprWireList`].

[#IterExprFunctionInvoke_name]
=== `char const* name()`
Returns the name of the function gate.

----
virtual char const* name() = 0;
----

[#IterExprFunctionInvoke_outputList]
=== `wtk::IterExprWireList* outputList()`
Returns a xref:#struct_IterExprWireList[`wtk::IterExprWireList`] for the output wires of this invocation.

----
virtual wtk::IterExprWireList* outputList() = 0;
----

[#IterExprFunctionInvoke_inputList]
=== `wtk::IterExprWireList* inputList()`
Returns a xref:#struct_IterExprWireList[`wtk::IterExprWireList`] for the input wires of this invocation.

----
virtual wtk::IterExprWireList* inputList() = 0;
----

[#IterExprFunctionInvoke_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the function invocation begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_IterExprAnonFunction]
== `template<typename Number_T> struct IterExprAnonFunction`
The `wtk::IterExprAnonFunction<Number_T>` is the simultaneous declaration and invocation of an anonymous function-gate as the body of a for-loop.
It mirrors the structure of both xref:#struct_FunctionDeclare[`wtk::FunctionDeclare<Number_T>`] and xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`], although without certain attributes such as `name()`, and with the input and output lists replaced by xref:#struct_IterExprWireList[`wtk::IterExprWireList`]

[#IterExprAnonFunction_outputList]
=== `wtk::IterExprWireList* outputList()`
Returns a xref:#struct_IterExprWireList[`wtk::IterExprWireList`] for the output wires of this anonymous function.

----
virtual wtk::IterExprWireList* outputList() = 0;
----

[#IterExprAnonFunction_inputList]
=== `wtk::IterExprWireList* inputList()`
Returns a xref:#struct_IterExprWireList[`wtk::IterExprWireList`] for the input wires of this anonymous function.

----
virtual wtk::IterExprWireList* inputList() = 0;
----

[#IterExprAnonFunction_instanceCount]
=== `wtk::index_t instanceCount()`
Returns the number of instance values this anonymous function gate will consume.

----
virtual wtk::index_t instanceCount() = 0;
----

[#IterExprAnonFunction_shortWitnessCount]
=== `wtk::index_t shortWitnessCount()`
Returns the number of short witness values this anonymous function gate will consume.

----
virtual wtk::index_t shortWitnessCount() = 0;
----

[#IterExprAnonFunction_body]
=== `wtk::DirectiveList<Number_T>* body()`
returns the body of the anonymous function gate.

----
virtual DirectiveList<Number_T>* body() = 0;
----

[#IterExprAnonFunction_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the anonymous function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_ForLoop]
== `template<typename Number_T> struct ForLoop`
This represents a for-loop directive in the IR.

[#ForLoop_outputList]
=== `wtk::WireList* outputList()`
Returns the output list of the _entire for-loop_ (not to be confused with the output list of _one iteration of the for-loop_) as a xref:#struct_WireList[`wtk::WireList`].

----
virtual WireList* outputList() = 0;
----

[#ForLoop_iterName]
=== `char const* iterName()`
Returns the name of the loop's iterator.

----
virtual char const* iterName() = 0;
----

[#ForLoop_first]
=== `wtk::index_t first()`
Returns the first iteration of the loop (inclusive).

----
virtual wtk::index_t first() = 0;
----

[#ForLoop_last]
=== `wtk::index_t last()`
Returns the last iteration of the loop (inclusive).

----
virtual wtk::index_t last() = 0;
----

[#ForLoop_enum_BodyType]
=== `enum BodyType`
An enumeration to indicate whether the loop's body is named or anonymous.

`wtk::ForLoop<Number_T>::INVOKE`:: Named body (use xref:#ForLoop_invokeBody[`this->invokeBody()`] and xref:#struct_IterExprFunctionInvoke[`wtk::IterExprFunctionInvoke`]).
`wtk::ForLoop<Number_T>::ANONYMOUS`:: Anonymous body (use xref:#ForLoop_anonymousBody[`this->anonymousBody()`] and xref:#struct_IterExprAnonFunction[`wtk::IterExprAnonFunction<Number_T>`]).

[#ForLoop_bodyType]
=== `BodyType bodyType()`
Returns the body type of this for-loop.

----
virtual BodyType bodyType() = 0;
----

[#ForLoop_invokeBody]
=== `wtk::IterExprFunctionInvoke* invokeBody()`
Returns the body of this for-loop as an xref:#struct_IterExprFunctionInvoke[`wtk::IterExprFunctionInvoke`].
If the loop's body type is not `xref:#ForLoop_bodyType[this->bodyType()] == xref:#ForLoop_enum_BodyType[wtk::ForLoop<Number_T>::INVOKE]`, then undefined behavior occurs.

----
virtual IterExprFunctionInvoke* invokeBody() = 0;
----

[#ForLoop_anonymousBody]
=== `wtk::IterExprAnonFunction<Number_T>* anonymousBody()`
Returns the body of this for-loop as an xref:#struct_IterExprAnonFunction[`wtk::IterExprAnonFunction<Number_T>`].
If the loop's body type is not `xref:#ForLoop_bodyType[this->bodyType()] == xref:#ForLoop_enum_BodyType[wtk::ForLoop<Number_T>::ANONYMOUS]`, then undefined behavior occurs.

----
virtual IterExprAnonFunction<Number_T>* anonymousBody() = 0;
----

[#ForLoop_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the for-loop begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_CaseFunctionInvoke]
== `struct CaseFunctionInvoke`
The `wtk:CaseFunctionInvoke` invokes a function gate as the body of a switch-case.
It mirrors the form of xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`], however, as the body of a switch-case, it is missing `outputList()`.

[#CaseFunctionInvoke_name]
=== `char const* name()`
Returns the name of the function gate.

----
virtual char const* name() = 0;
----

[#CaseFunctionInvoke_inputList]
=== `wtk::WireList* inputList()`
Returns a xref:#struct_WireList[`wtk::WireList`] for the input wires of this invocation.

----
virtual wtk::WireList* inputList() = 0;
----

[#CaseFunctionInvoke_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the function invocation begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_CaseAnonFunction]
== `template<typename Number_T> struct CaseAnonFunction`
The `wtk:CaseAnonFunction` is the simultaneous declaration and invocation of an anonymous function-gate as the body of a switch-case.
It mirrors the structure of both xref:#struct_FunctionDeclare[`wtk::FunctionDeclare<Number_T>`] and xref:#struct_FunctionInvoke[`wtk::FunctionInvoke`], although without certain attributes such as `name()` or, as the body of a switch-case,  `outputList()`.

[#CaseAnonFunction_inputList]
=== `wtk::WireList* inputList()`
Returns a xref:#struct_WireList[`wtk::WireList`] for the input wires of this anonymous function.

----
virtual wtk::WireList* inputList() = 0;
----

[#CaseAnonFunction_instanceCount]
=== `wtk::index_t instanceCount()`
Returns the number of instance values this anonymous function gate will consume.

----
virtual wtk::index_t instanceCount() = 0;
----

[#CaseAnonFunction_shortWitnessCount]
=== `wtk::index_t shortWitnessCount()`
Returns the number of short witness values this anonymous function gate will consume.

----
virtual wtk::index_t shortWitnessCount() = 0;
----

[#CaseAnonFunction_body]
=== `wtk::DirectiveList<Number_T>* body()`
returns the body of the anonymous function gate.

----
virtual DirectiveList<Number_T>* body() = 0;
----

[#CaseAnonFunction_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the anonymous function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_CaseBlock]
== `template<typename Number_T> struct CaseBlock`
This represents a case within a switch-statement.

[#CaseBlock_match]
=== `Number_T match()`
Returns the field-literal which is matched against the switch-statement's xref:#SwitchStatement_condition[`condition()`] wire to indicate if this case is active.

----
virtual Number_T match() = 0;
----

[#CaseBlock_enum_BodyType]
=== `enum BodyType`
An enumeration to indicate whether the case's body is named or anonymous.

`wtk::CaseBlock<Number_T>::INVOKE`:: Named body (use xref:#CaseBlock_invokeBody[`this->invokeBody()`] and xref:#struct_CaseFunctionInvoke[`wtk::CaseFunctionInvoke`]).
`wtk::CaseBlock<Number_T>::ANONYMOUS`:: Anonymous body (use xref:#CaseBlock_anonymousBody[`this->anonymousBody()`] and xref:#struct_CaseAnonFunction[`wtk::CaseAnonFunction<Number_T>`]).

[#CaseBlock_bodyType]
=== `BodyType bodyType()`
Returns the body type of this case block.

----
virtual BodyType bodyType() = 0;
----

[#CaseBlock_invokeBody]
=== `wtk::CaseFunctionInvoke* invokeBody()`
Returns the body of this case-block as a xref:#struct_CaseFunctionInvoke[`wtk::CaseFunctionInvoke`].
If the case's body type is not `xref:#CaseBlock_bodyType[this->bodyType()] == xref:#CaseBlock_enum_BodyType[wtk::CaseBlock<Number_T>::INVOKE]`, then undefined behavior occurs.

----
virtual CaseFunctionInvoke* invokeBody() = 0;
----

[#CaseBlock_anonymousBody]
=== `wtk::CaseAnonFunction<Number_T>* anonymousBody()`
Returns the body of this case-block as a xref:#struct_CaseAnonFunction[`wtk::CaseAnonFunction<Number_T>`].
If the case's body type is not `xref:#CaseBlock_bodyType[this->bodyType()] == xref:#CaseBlock_enum_BodyType[wtk::CaseBlock<Number_T>::ANONYMOUS]`, then undefined behavior occurs.

----
virtual CaseAnonFunction<Number_T>* anonymousBody() = 0;
----

[#CaseBlock_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the case-block begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----

[#struct_SwitchStatement]
== `template<typename Number_T> struct SwitchStatement`
This represents a switch-statement directive in the IR.

[#SwitchStatement_outputList]
=== `wtk::WireList* outputList()`
Returns the switch-statement's output list as a xref:#struct_WireList[`wtk::WireList`].

----
virtual wtk::WireList* outputList() = 0;
----

[#SwitchStatement_condition]
=== `wtk::index_t condition()`
Returns the condition (or "selector") wire of this switch-statement.

----
virtual wtk::index_t condition() = 0;
----

[#SwitchStatement_size]
=== `size_t size()`
Returns the number of cases in the switch-statement.

----
virtual size_t size() = 0;
----

[#SwitchStatement_caseBlock]
=== `wtk::CaseBlock<Number_T>* caseBlock(size_t n)`
Returns the ``n``th xref:#struct_CaseBlock[`wtk::CaseBlock<Number_T>`] in this switch-statement.
If `n` is outside of the range `n >= 0 && n < xref:#SwitchStatement_size[this->size()]`, then undefined behavior occurs.

----
virtual CaseBlock<Number_T>* caseBlock(size_t n) = 0;
----

[#SwitchStatement_lineNum()]
=== `size_t lineNum()`
Returns the line number at which the switch-statement begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case `0` is always returned.

----
virtual size_t lineNum();
----
