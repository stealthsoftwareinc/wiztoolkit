<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Parsing the IR - WizToolKit</title>
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/fonts.css" />
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/layout.css" />
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/content.css" />

    <link rel="shortcut icon" type="image/png"
        href="/wiztoolkit/assets/icons/tetra-solid-32x32.png" />

    <link type="application/atom+xml" rel="alternate" href="https://stealthsoftwareinc.github.io/wiztoolkit/feed.xml" title="WizToolKit" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Parsing the IR | WizToolKit</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Parsing the IR" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html" />
<meta property="og:url" content="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html" />
<meta property="og:site_name" content="WizToolKit" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Parsing the IR" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Parsing the IR","url":"https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html"}</script>
<!-- End Jekyll SEO tag -->


    <script>0</script>
  </head>
  <body>
    <header>
      <nav id="topNav">
        <a href="#main" id="jumpMain">Jump to Main</a>
        <a href="https://www.stealthsoftwareinc.com" id="logoImg">
          <img
            src="/wiztoolkit/assets/icons/tetra-solid-100x100.png"
            alt="Stealth Software Technologies Home Page" /></a>
        <a href="/wiztoolkit/" id="titleLink">WizToolKit</a>
        <span id="spacer">&nbsp;</span>
        
          
            <a href="/wiztoolkit/"
              
              >about</a>
          
        
          
            <a href="/wiztoolkit/docs/v1.0.1/"
              
              >docs</a>
          
        
          
            <a href="https://github.com/stealthsoftwareinc/wiztoolkit"
              
              >source</a>
          
        
      </nav>
    </header>
    <nav id=docsNav>
  <div>
    <h2 class="eyebrow">Docs Nav</h2>
    <p>
      <label for="version_select">Change Version:</label> <select name="version_select" onchange="location = this.value;"><option selected value="/wiztoolkit/docs/v1.0.1/">v1.0.1</option></select>
    </p>

    
    <ul><li><a href="/wiztoolkit//docs/v1.0.1/">WizToolKit</a><ul><li><a href="/wiztoolkit/docs/v1.0.1/backends.html">WizToolKit for Backends</a></li><li><a href="/wiztoolkit/docs/v1.0.1/commandline.html">WizToolKit on the Command-Line</a></li><li><a href="/wiztoolkit/docs/v1.0.1/install.html">Installing WizToolKit</a></li><li class="curr_page"><a href="/wiztoolkit/docs/v1.0.1/parsers.html">Parsing the IR</a>
      <ul class="sectlevel1">
<li><a href="#numbers-in-the-ir">Numbers in the IR</a></li>
<li><a href="#parsing-options">Parsing Options</a></li>
<li><a href="#parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</a></li>
<li><a href="#Streaming-API">Streaming API for Relations</a></li>
<li><a href="#Syntax-Tree-API">Syntax Tree API for Relations</a>
<ul class="sectlevel2">
<li><a href="#Syntax-Tree-Functions">Syntax Tree API for Functions</a></li>
</ul>
</li>
</ul>
    </li><li><a href="/wiztoolkit/docs/v1.0.1/single_page_manual.html">WizToolKit Manual</a></li><li>api<ul><li>wtk<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/ArithmeticStreamHandler.html">Arithmetic Stream Handler API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/BooleanStreamHandler.html">Boolean Stream Handler API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/IRParameters.html">IRParameters API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/IRTree.html">IR Tree API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/Parser.html">Parser API</a></li><li>bolt<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/ArithmeticPLASMASnoozeHandler.html">Arithmetic PLASMASnooze Streaming API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Backend.html">BOLT Backend API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/BooleanPLASMASnoozeHandler.html">Boolean PLASMASnooze Streaming API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Builder.html">BOLT Builder API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Evaluator.html">BOLT Evaluator API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/PLASMASnooze.html">PLASMASnooze</a></li></ul></li><li>antlr<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/antlr/Parser.html">ANTLR Parser API</a></li></ul></li><li>flatbuffer<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/flatbuffer/Parser.html">FlatBuffer Parser API</a></li></ul></li><li>irregular<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/irregular/Parser.html">IRRegular Parser API</a></li></ul></li></ul></li></ul></li><li>tools<ul><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-bolt.html">BOLT (Example and Testing)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-firealarm.html">FIREALARM (Checking and Evaluating)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-press.html">PRESS (Format and Feature Conversion)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-viz.html">Viz (Visualization)</a></li></ul></li></ul></li></ul>
  </div>
</nav>

<main id="main" tabindex="-1">
  <h1>Parsing the IR</h1>
  <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#numbers-in-the-ir">Numbers in the IR</a></li>
<li><a href="#parsing-options">Parsing Options</a></li>
<li><a href="#parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</a></li>
<li><a href="#Streaming-API">Streaming API for Relations</a></li>
<li><a href="#Syntax-Tree-API">Syntax Tree API for Relations</a>
<ul class="sectlevel2">
<li><a href="#Syntax-Tree-Functions">Syntax Tree API for Functions</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>WizToolKit has a simple unified API for parsing both forms of the IR.
This page will start with number representations in the IR, then explain the options available for parsing, and finally a deeper dive into common paths for parsing.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="numbers-in-the-ir">Numbers in the IR</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The SIEVE IR has two distint categories of numbers</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Wire indexes</dt>
<dd>
<p>These are represented with <code>wtk::index_t</code>, a typedef of <code>uint64_t</code>.</p>
</dd>
<dt class="hdlist1">Field element literals</dt>
<dd>
<p>These are numbers mod the relations <code>characteristic</code>, which may be arbitrarily large. For maximal flexibility, WizToolKit uses a <code>Number_T</code> template parameter, which should be integer-like (e.g. implement operators for <code>+</code>, <code>*</code>, <code>&lt;&lt;</code>, etc. Enough to implement string-to-int conversions).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsing-options">Parsing Options</h2>
<div class="sectionbody">
<div class="paragraph">
<p>WizToolKit has three parser implementations, however all implement a common interface through the <code>wtk::Parser&lt;Number_T&gt;</code> abstract class (<a href="api/wtk/Parser.html#api_Parser"><code>#include &lt;wtk/Parser.h&gt;</code></a>).
It is responsible for parsing the IR&#8217;s front matter, returning control for the user to decide how to parse the IR body, and then delegating the body to a helper, also with a common interface.</p>
</div>
<div class="paragraph">
<p>As an abstract class, <code>wtk::Parser&lt;Number_T&gt;</code> must be instantiated as one of its concrete implementations. WizToolKit offers three such implementations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wtk::antlr::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/antlr/Parser.html#api_antlr_Parser"><code>#include &lt;wtk/antlr/Parser.h&gt;</code></a>)</p>
</li>
<li>
<p><code>wtk::irregular::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/irregular/Parser.html#api_irregular_Parser"><code>#include &lt;wtk/irregular/Parser.h&gt;</code></a>)</p>
</li>
<li>
<p><code>wtk::flatbuffer::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser"><code>#include &lt;wtk/flatbuffer/Parser.h&gt;</code></a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All have a constructor which takes a <code>std::string</code> naming the file to open.
Some have additional constructors.</p>
</div>
<div class="paragraph">
<p>Before going any further, it is worth thinking about the context for parsing the IR.
Is just a relation being parsed? Are all three of relation, instance, and short witness being parsed?
When parsing all three, we have found it easiest to expect them listed in a defined order and fail if they deviate rather than attempting to reorder them on the fly.
Later in this page we will show the expected order approach.</p>
</div>
<div class="paragraph">
<p>Here is the creation of an IRRegular parser with <code>unsigned long</code> as its <code>Number_T</code> (field-literal type).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">std::string relation_name = /* ... */;

wtk::irregular::Parser&lt;unsigned long&gt; parser(relation_name);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the parser is created, the front matter is easy to parse.
<a href="api/wtk/Parser.html#Parser_parseHdrResParams"><code>parser.parseHdrResParams()</code></a> returns <code>true</code> on success, and sets public attributes of the <code>parser</code> for front matter attributes.
To check that it is a relation, the parser has a <code>resource</code> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">if(!parser.parseHdrResParams()
    || parser.resource != wtk::Resource::relation)
{
  /* handle errors */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a summary of the front matter attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="api/wtk/Parser.html#Parser_version"><code>parser.version</code></a> is the IR version number. Its a triplet of <code>major</code>, <code>minor</code>, and <code>patch</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
WizToolKit makes little attempt to handle older IR releases.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="api/wtk/Parser.html#Parser_characteristic"><code>parser.characteristic</code></a> (<code>Number_T</code>) and <a href="api/wtk/Parser.html#Parser_degree"><code>parser.degree</code></a> (<code>size_t</code>) form the field.</p>
</li>
<li>
<p><a href="api/wtk/Parser.html#Parser_resource"><code>parser.resource</code></a> is the resource type. <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource</code></a> is an enum with the following values</p>
<div class="ulist">
<ul>
<li>
<p><code>wtk::Resource::relation</code></p>
</li>
<li>
<p><code>wtk::Resource::instance</code></p>
</li>
<li>
<p><code>wtk::Resource::shortWitness</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="api/wtk/Parser.html#Parser_gateSet"><code>parser.gateSet</code></a> and <a href="api/wtk/Parser.html#Parser_featureToggles"><code>parser.featureToggles</code></a> are structs with indicators for which gates and which IR features are used by this relation. See <a href="api/wtk/IRParameters.html#struct_GateSet"><code>struct GateSet</code></a> and <a href="api/wtk/IRParameters.html#struct_FeatureToggles"><code>struct FeatureToggles</code></a></p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
The <a href="api/wtk/Parser.html#Parser_gateSet"><code>parser.gateSet</code></a> and <a href="api/wtk/Parser.html#Parser_featureToggles"><code>parser.featureToggles</code></a> attributes are assigned only for the relation, not for the instance or short witness.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now the user may check the front matter for acceptability.
For example, that the characteristic is prime, or from a specific family of primes.
The user may also want to error here if the <em>Gate Set</em> or a <em>Feature Toggle</em> is unsupported.</p>
</div>
<div class="paragraph">
<p>Next, the user must choose how to parse the body, the instance, and the short witness.
The headers of the instance and short witness can be parsed similarly to the relation&#8217;s.
However, the instance and short_witness do not have <em>Gate Set</em> or <em>Feature Toggles</em>, and must defer to the <em>relation</em>.</p>
</div>
<div class="paragraph">
<p>A critical decision is whether the <em>Gate Set</em> is <a href="api/wtk/Parser.html#struct_BooleanParser"><em>Boolean</em></a> or <a href="api/wtk/Parser.html#struct_ArithmeticParser"><em>arithmetic</em></a>.
This is because the parsing API splits on these boundaries.
Another potential decision is whether or not the relation is IR-<em>Simple</em>.
WizToolKit&#8217;s parsers have a streaming API for IR-Simple, which may improve performance for some relations.
However, the streaming API cannot handle non-simple relations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">std::string instance_name = /* ... */;
std::string short_witness_name = /* ... */;
wtk::irregular::Parser&lt;unsigned long&gt; instance_parser(instance_name);
wtk::irregular::Parser&lt;unsigned long&gt; short_witness_parser(short_witness_name);

if(!instance_parser.parseHdrResParams()
    || !short_witness_parser.parseHdrResParams()
    || parser.characteristic != instance_parser.characteristic
    || parser.characteristic != short_witness_parser.characteristic)
{
  /* handle error */
}

if(parser.resource == wtk::Resource::relation)
  &amp;&amp; parser.gateSet.gateSet == wtk::GateSet::arithmetic)
{
  // Parse arithmetic relation
  wtk::AritmeticParser&lt;unsigned long&gt;* arith_parser = parser.arithmetic();

  if(parser.featureToggles.simple()) // select the streaming API
  {
    // See <a href="#Streaming-API">Streaming API</a>
  }
  else
  {
    // See <a href="#Syntax-Tree-API">Syntax Tree API</a>
  }
}
else if(parser.resource == wtk::Resource::relation)
  &amp;&amp; parser.gateSet.gateSet == wtk::GateSet::boolean)
{
  // Parse boolean relation, Note that the template is dropped,
  // because Boolean literals are always given as uint8_t.
  wtk::BooleanParser* bool_parser = parser.arithmetic();
  /* Omitted... */
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Both the instance and short-witness are abstracted as streams in the SIEVE IR.
WizToolKit handles these streams through the <a href="api/wtk/Parser.html#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;</code></a> API.</p>
</div>
<div class="paragraph">
<p>The <code>wtk::InputStream&lt;Number_T&gt;</code> objects are obtained through the parser after specializing to <a href="api/wtk/Parser.html#ArithmeticParser_instance">arithmetic</a> or <a href="api/wtk/Parser.html#BooleanParser_shortWitness">boolean</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">// Get an arithmetic parser for an instance
wtk::ArithmeticParser&lt;unsigned long&gt;* a_ins_parser = instance_parser.arithmetic();
wtk::InputStream&lt;unsigned long&gt;* a_ins = a_ins_parser-&gt;instance();

// Similarly, for Boolean short witness (as an example; instance and short
// witness should have the same type).
wtk::BooleanParser* b_wit_parser = short_witness_parser.arithmetic();
wtk::InputStream&lt;uint8_t&gt;* b_wit = b_wit_parser-&gt;shortWitness();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a stream is obtained, its <a href="api/wtk/Parser.html#InputStream_next"><code>next(&#8230;&#8203;)</code></a> method may be called repeatedly for each element of the stream.
The return type of <code>next(&#8230;&#8203;)</code> will indicate if it succeeded, failed, or reached the end of the stream. It has a return-by-pointer argument for the stream element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">unsigned long ins_val = 0;
wtk::StreamStatus status = a_ins-&gt;next(&amp;ins_val);
if(status == wtk::StreamStatus::end) { /* End of stream */ }
else if(status == wtk::StreamStatus::error) { /* mid-stream parser error */ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of the parsers (namely <a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR</a> and <a href="api/wtk/antlr/Parser.html#api_flatbuffer_Parser">FlatBuffer</a>) will parse the entire stream up front, in which case a parser error is indicated on the first element, regardless of its place in the stream.
Other parsers (namely <a href="api/wtk/irregular/Parser.html#api_irregular_Parser">IRRegular</a>) work in a more true stream-wise fashion, reporting the error as it occurs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Streaming-API">Streaming API for Relations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Streaming API, IR-<em>Simple</em> relations are parsed one gate at a time and reported immediately.
This only works for IR-<em>Simple</em> because these relations have no nested scopes or repetition.</p>
</div>
<div class="paragraph">
<p>To report gates, the user must implement the <a href="api/wtk/ArithmeticStreamHandler.html#api_ArithmeticStreamHandler"><code>wtk::ArithmeticStreamHandler&lt;Number_T&gt;</code></a> or <a href="api/wtk/BooleanStreamHandler.html#api_BooleanStreamHandler"><code>wtk::BooleanStreamHandler</code></a> abstract class (depending on <em>Gate Set</em>, obviously).
A brief example for Arithmetic is shown here.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">class UserArithmeticStreamHandler : public wtk::ArithmeticStreamHandler&lt;unsigned long&gt;
{
  void handleAdd(wtk::index_t const out, // output wire-number
      wtk::index_t const left_in,        // left input wire-number
      wtk::index_t const right_in)       // right input wire-number
    override
  {
    /* omitted */
  }

  void handleMul(wtk::index_t const out, // output wire-number
      wtk::index_t const left_in,        // left input wire-number
      wtk::index_t const right_in)       // right input wire-number
    override
  {
    /* omitted */
  }

  /* Remaining methods omitted... */
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Invocation for the streaming API is through the <a href="api/wtk/Parser.html#ArithmeticParser_parseStream"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code> method <code>parseStream(&#8230;&#8203;)</code></a> or <a href="api/wtk/Parser.html#BooleanParser_parseStream"><code>wtk::BooleanParser</code> method <code>parseStream(&#8230;&#8203;)</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">// For an arithmetic simple relation
UserArithmeticStreamHandler handler;
if(!arith_parser-&gt;parseStream(&amp;handler)) { /* Parse Error */ }

// For a Boolean simple relation
UserBooleanStreamHandler handler;
if(!bool_parser-&gt;parseStream(&amp;handler)) { /* Parse Error */ }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Syntax-Tree-API">Syntax Tree API for Relations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Syntax Tree API can handle any relation, regardless of its feature set.
However, it must parse the entire relation ahead of time, and allocate a syntax tree, which for very long relations can consume a lot of memory.</p>
</div>
<div class="paragraph">
<p>The syntax tree is defined by <a href="api/wtk/IRTree.html#api_IRTree">#include &lt;wtk/IRTree.h&gt;</a>.
At a top-level it is defined by the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a>, which aggregates function definitions and the relation&#8217;s main body.
Each scope is a <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;</code></a> with the ability to retrieve gates such as <a href="api/wtk/IRTree.html#struct_BinaryGate"><code>wtk::BinaryGate</code></a> (binary referring to its cardinality) or <a href="api/wtk/IRTree.html#struct_Input"><code>wtk::Input</code></a> (for the instance or short-witness).</p>
</div>
<div class="paragraph">
<p>The Tree is again retrieved through the <a href="api/wtk/Parser.html#ArithmeticParser_parseTree"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code></a> or <a href="api/wtk/Parser.html#BooleanParser_parseTree"><code>wtk::BooleanParser</code></a> <code>parseTree()</code> method (only Arithmetic shown).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">wtk::IRTree&lt;unsigned long&gt;* ir_tree = arith_parser-&gt;parseTree();
if(ir_tree == nullptr) { /* Parser error */ }

// To be implemented by the user.
process_ir_tree(ir_tree);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To process the relation, the user must do a tree traversal.
At a top level, the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> holds a list of function declarations (we&#8217;ll get to these later), and the relation&#8217;s main body.
The main body is just a <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;</code></a>, which is an indirectly-recursive type, defining much of the syntax tree.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">void process_ir_tree(wtk::IRTree&lt;unsigned long&gt;* tree)
{
  // See <a href="#Syntax-Tree-Functions">Syntax Tree API for Functions</a> for function-declarations.

  // The circuit's entry point is its body.
  process_directive_list(tree-&gt;body());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Processing the <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number-T&gt;</code></a> is a simple matter of traversing each directive in the scope, and switching on its <a href="api/wtk/IRTree.html#DirectiveList_enum_Type">type</a>.
Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">void process_directive_list(wtk::DirectiveList&lt;unsigned long&gt;* dir_list)
{
  // The DirectiveList is a tree type, leaf-nodes are typically gates
  // (@and/@xor/@mul/etc.) with other nodes taking the form of higher
  // level features.

  for(size_t i = 0; i &lt; dir_list-&gt;size(); i++)
  {
    switch(dir_list-&gt;type(i))
    {
    case wtk::DirectiveList&lt;unsigned long&gt;::BINARY_GATE:
    {
      // the "binary" (in signature, not value) gate describes
      // @and/@xor/@mul/@add gates.
      wtk::BinaryGate* gate = dir_list-&gt;binaryGate(i);
      // these are the input and output wire numbers of the gate
      wtk::index_t left_input_wire = gate-&gt;leftWire();
      wtk::index_t right_input_wire = gate-&gt;rightWire();
      wtk::index_t output_wire = gate-&gt;outputWire();

      // The gate's calculation is an enum
      switch(gate-&gt;calculation())
      {
      case wtk::BinaryGate::AND: { break; }
      case wtk::BinaryGate::XOR: { break; }
      case wtk::BinaryGate::ADD: { break; }
      case wtk::BinaryGate::MUL: { break; }
      }

      break;
    }
    /* other gate-types omitted for brevity */
    case wtk::DirectiveList&lt;unsigned long&gt;::ANON_FUNCTION:
    {
      wtk::AnonFunction&lt;unsigned long&gt;* anon_func = dir_list-&gt;anonFunction(i);
      // The signature of the function, along with its inputs/outputs
      // is easily retrievable.
      wtk::WireList* output_wires = anon_func-&gt;outputList();
      wtk::WireList* input_wires = anon_func-&gt;inputList();
      wtk::index_t num_instance_vals = anon_func-&gt;instanceCount();
      wtk::index_t num_witness_vals = anon_func-&gt;shortWitnessCount();

      // To process the body of the anonymous function, use recursion.
      process_directive_list(anon_func-&gt;body());
      break;
    }
    /* Other feature-types omitted for brevity */
    }
  }
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="Syntax-Tree-Functions">Syntax Tree API for Functions</h3>
<div class="paragraph">
<p>For IR named-functions, the body of a function and its invocation are split.
All function-declarations are listed at the top of a relation.
Correspondingly, the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> has a <a href="api/wtk/IRTree.html#IRTree_functionDeclare"><code>functionDeclare(i)</code></a> method for retrieval, and <a href="api/wtk/IRTree.html#IRTree_size"><code>size()</code></a> indicating how many may be retrieved.</p>
</div>
<div class="paragraph">
<p>For easy access, we suggest entering the function declarations into a <code>std::map</code> or <code>std::unordered_map</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">// declare a map to hold them
std::map&lt;std::string, wtk::FunctionDeclare&lt;unsigned long&gt;*&gt; functions_map;

  // enter each function-declaration into the map
  for(size_t i = 0; i &lt; tree-&gt;size(); i++)
  {
    wtk::FunctionDeclare&lt;unsigned long&gt;* function = tree-&gt;functionDeclare(i);

    // function-&gt;name() is a char* while std::map works only with std::strings
    // with c++17, it should be okay to use std::string_view so long as
    // *tree outlives functions_map
    std::string name(function-&gt;name());

    // check that the function wasn't previously declared
    auto finder = functions_map.find(name);
    if(finder != functions_map.end()) { /* Error */ }

    functions_map[name] = function;
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a function is invoked (with a <a href="api/wtk/IRTree.html#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a> directive), its is now just a matter of looking up its name in the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++">    case wtk::DirectiveList&lt;unsigned long&gt;::FUNCTION_INVOKE:
    {
      wtk::FunctionInvoke* invoke = dir_list-&gt;functionInvoke(i);

      std::string name(invoke-&gt;name());
      auto finder = functions_map.find(name);
      if(finder == functions_map.end()) { /* Error */ }

      wtk::FunctionDeclare&lt;unsigned long&gt;* declaration = finder-&gt;second;

      // To process the body of the function, use recursion.
      process_directive_list(declaration-&gt;body());
      break;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information about the IR Syntax Tree, See <a href="api/wtk/IRTree.html#api_IRTree"><code>#include &lt;wtk/IRTree.h&gt;</code></a>.</p>
</div>
</div>
</div>
</div>
</main>

    <footer>
      
        <p id="distributionStatement">
          <strong>Distribution Statement A:</strong> Approved for Public Release, Distribution Unlimited.
        </p>
      
      <p>
        Copyright &copy; 2022, Stealth Software Technologies, Inc.
        All Rights Reserved.
      </p>
      
        <p id="acknowledgement">
          This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087. The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
        </p>
      

      <a href="https://www.stealthsoftwareinc.com" id="bottomLogoImg">
        <img
          src="/wiztoolkit/assets/icons/tetra-solid-400x100.png"
          alt="Stealth Software Technologies Home Page" /></a>

      
    </footer>
  </body>
</html>

