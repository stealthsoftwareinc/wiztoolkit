<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Parsing the IR - WizToolKit</title>
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/fonts.css" />
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/layout.css" />
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/content.css" />

    <link rel="shortcut icon" type="image/png"
        href="/wiztoolkit/assets/icons/tetra-solid-32x32.png" />

    <link type="application/atom+xml" rel="alternate" href="https://stealthsoftwareinc.github.io/wiztoolkit/feed.xml" title="WizToolKit" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Parsing the IR | WizToolKit</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Parsing the IR" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html" />
<meta property="og:url" content="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html" />
<meta property="og:site_name" content="WizToolKit" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Parsing the IR" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Parsing the IR","url":"https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/parsers.html"}</script>
<!-- End Jekyll SEO tag -->


    <script>0</script>
  </head>
  <body>
    <header>
      <nav id="topNav">
        <a href="#main" id="jumpMain">Jump to Main</a>
        <a href="https://www.stealthsoftwareinc.com" id="logoImg">
          <img
            src="/wiztoolkit/assets/icons/tetra-solid-100x100.png"
            alt="Stealth Software Technologies Home Page" /></a>
        <a href="/wiztoolkit/" id="titleLink">WizToolKit</a>
        <span id="spacer">&nbsp;</span>
        
          
            <a href="/wiztoolkit/"
              
              >about</a>
          
        
          
            <a href="/wiztoolkit/docs/v2.1.0/"
              
              >docs</a>
          
        
          
            <a href="https://github.com/stealthsoftwareinc/wiztoolkit"
              
              >source</a>
          
        
      </nav>
    </header>
    <nav id=docsNav>
  <div>
    <h2 class="eyebrow">Docs Nav</h2>
    <p>
      <label for="version_select">Change Version:</label> <select name="version_select" onchange="location = this.value;"><option  value="/wiztoolkit/docs/v2.1.0/">v2.1.0</option><option selected value="/wiztoolkit/docs/v1.0.1/">v1.0.1</option></select>
    </p>

    
    <ul><li><a href="/wiztoolkit/docs/v1.0.1/">WizToolKit</a><ul><li>api<ul><li>wtk<ul><li>antlr<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/antlr/Parser.html">ANTLR Parser API</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/ArithmeticStreamHandler.html">Arithmetic Stream Handler API</a></li><li>bolt<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/ArithmeticPLASMASnoozeHandler.html">Arithmetic PLASMASnooze Streaming API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Backend.html">BOLT Backend API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/BooleanPLASMASnoozeHandler.html">Boolean PLASMASnooze Streaming API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Builder.html">BOLT Builder API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Evaluator.html">BOLT Evaluator API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/PLASMASnooze.html">PLASMASnooze</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/BooleanStreamHandler.html">Boolean Stream Handler API</a></li><li>flatbuffer<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/flatbuffer/Parser.html">FlatBuffer Parser API</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/IRParameters.html">IRParameters API</a></li><li>irregular<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/irregular/Parser.html">IRRegular Parser API</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/IRTree.html">IR Tree API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/Parser.html">Parser API</a></li></ul></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/backends.html">WizToolKit for Backends</a></li><li><a href="/wiztoolkit/docs/v1.0.1/commandline.html">WizToolKit on the Command-Line</a></li><li><a href="/wiztoolkit/docs/v1.0.1/install.html">Installing WizToolKit</a></li><li class="curr_page"><a href="/wiztoolkit/docs/v1.0.1/parsers.html">Parsing the IR</a>
      <ul class="sectlevel1">
<li><a href="#numbers-in-the-ir">Numbers in the IR</a></li>
<li><a href="#parsing-options">Parsing Options</a></li>
<li><a href="#parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</a></li>
<li><a href="#Streaming-API">Streaming API for Relations</a></li>
<li><a href="#Syntax-Tree-API">Syntax Tree API for Relations</a>
<ul class="sectlevel2">
<li><a href="#Syntax-Tree-Functions">Syntax Tree API for Functions</a></li>
</ul>
</li>
</ul>
    </li><li><a href="/wiztoolkit/docs/v1.0.1/single_page_manual.html">WizToolKit Manual</a></li><li>tools<ul><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-bolt.html">BOLT (Example and Testing)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-firealarm.html">FIREALARM (Checking and Evaluating)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-press.html">PRESS (Format and Feature Conversion)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-viz.html">Viz (Visualization)</a></li></ul></li></ul></li></ul>
  </div>
</nav>

<main id="main" tabindex="-1">
  <h1>Parsing the IR</h1>
  <div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#numbers-in-the-ir">Numbers in the IR</a></li>
<li><a href="#parsing-options">Parsing Options</a></li>
<li><a href="#parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</a></li>
<li><a href="#Streaming-API">Streaming API for Relations</a></li>
<li><a href="#Syntax-Tree-API">Syntax Tree API for Relations</a>
<ul class="sectlevel2">
<li><a href="#Syntax-Tree-Functions">Syntax Tree API for Functions</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>WizToolKit has a simple unified API for parsing both forms of the IR.
This page will start with number representations in the IR, then explain the options available for parsing, and finally a deeper dive into common paths for parsing.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="numbers-in-the-ir">Numbers in the IR</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The SIEVE IR has two distint categories of numbers</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Wire indexes</dt>
<dd>
<p>These are represented with <code>wtk::index_t</code>, a typedef of <code>uint64_t</code>.</p>
</dd>
<dt class="hdlist1">Field element literals</dt>
<dd>
<p>These are numbers mod the relations <code>characteristic</code>, which may be arbitrarily large. For maximal flexibility, WizToolKit uses a <code>Number_T</code> template parameter, which should be integer-like (e.g. implement operators for <code>+</code>, <code>*</code>, <code>&lt;&lt;</code>, etc. Enough to implement string-to-int conversions).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsing-options">Parsing Options</h2>
<div class="sectionbody">
<div class="paragraph">
<p>WizToolKit has three parser implementations, however all implement a common interface through the <code>wtk::Parser&lt;Number_T&gt;</code> abstract class (<a href="api/wtk/Parser.html#api_Parser"><code>#include &lt;wtk/Parser.h&gt;</code></a>).
It is responsible for parsing the IR&#8217;s front matter, returning control for the user to decide how to parse the IR body, and then delegating the body to a helper, also with a common interface.</p>
</div>
<div class="paragraph">
<p>As an abstract class, <code>wtk::Parser&lt;Number_T&gt;</code> must be instantiated as one of its concrete implementations. WizToolKit offers three such implementations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wtk::antlr::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/antlr/Parser.html#api_antlr_Parser"><code>#include &lt;wtk/antlr/Parser.h&gt;</code></a>)</p>
</li>
<li>
<p><code>wtk::irregular::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/irregular/Parser.html#api_irregular_Parser"><code>#include &lt;wtk/irregular/Parser.h&gt;</code></a>)</p>
</li>
<li>
<p><code>wtk::flatbuffer::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser"><code>#include &lt;wtk/flatbuffer/Parser.h&gt;</code></a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All have a constructor which takes a <code>std::string</code> naming the file to open.
Some have additional constructors.</p>
</div>
<div class="paragraph">
<p>Before going any further, it is worth thinking about the context for parsing the IR.
Is just a relation being parsed? Are all three of relation, instance, and short witness being parsed?
When parsing all three, we have found it easiest to expect them listed in a defined order and fail if they deviate rather than attempting to reorder them on the fly.
Later in this page we will show the expected order approach.</p>
</div>
<div class="paragraph">
<p>Here is the creation of an IRRegular parser with <code>unsigned long</code> as its <code>Number_T</code> (field-literal type).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #dddddd">std::string relation_name = </span><span style="color: #00ff00">/* ... */</span><span style="color: #dddddd">;</span>

<span style="color: #dddddd">wtk::irregular::Parser&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt; parser(relation_name);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the parser is created, the front matter is easy to parse.
<a href="api/wtk/Parser.html#Parser_parseHdrResParams"><code>parser.parseHdrResParams()</code></a> returns <code>true</code> on success, and sets public attributes of the <code>parser</code> for front matter attributes.
To check that it is a relation, the parser has a <code>resource</code> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #ff0000">if</span><span style="color: #dddddd">(!parser.parseHdrResParams()</span>
<span style="color: #dddddd">    || parser.resource != wtk::Resource::relation)</span>
<span style="color: #dddddd">{</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">/* handle errors */</span>
<span style="color: #dddddd">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a summary of the front matter attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="api/wtk/Parser.html#Parser_version"><code>parser.version</code></a> is the IR version number. Its a triplet of <code>major</code>, <code>minor</code>, and <code>patch</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
WizToolKit makes little attempt to handle older IR releases.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="api/wtk/Parser.html#Parser_characteristic"><code>parser.characteristic</code></a> (<code>Number_T</code>) and <a href="api/wtk/Parser.html#Parser_degree"><code>parser.degree</code></a> (<code>size_t</code>) form the field.</p>
</li>
<li>
<p><a href="api/wtk/Parser.html#Parser_resource"><code>parser.resource</code></a> is the resource type. <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource</code></a> is an enum with the following values</p>
<div class="ulist">
<ul>
<li>
<p><code>wtk::Resource::relation</code></p>
</li>
<li>
<p><code>wtk::Resource::instance</code></p>
</li>
<li>
<p><code>wtk::Resource::shortWitness</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="api/wtk/Parser.html#Parser_gateSet"><code>parser.gateSet</code></a> and <a href="api/wtk/Parser.html#Parser_featureToggles"><code>parser.featureToggles</code></a> are structs with indicators for which gates and which IR features are used by this relation. See <a href="api/wtk/IRParameters.html#struct_GateSet"><code>struct GateSet</code></a> and <a href="api/wtk/IRParameters.html#struct_FeatureToggles"><code>struct FeatureToggles</code></a></p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
The <a href="api/wtk/Parser.html#Parser_gateSet"><code>parser.gateSet</code></a> and <a href="api/wtk/Parser.html#Parser_featureToggles"><code>parser.featureToggles</code></a> attributes are assigned only for the relation, not for the instance or short witness.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now the user may check the front matter for acceptability.
For example, that the characteristic is prime, or from a specific family of primes.
The user may also want to error here if the <em>Gate Set</em> or a <em>Feature Toggle</em> is unsupported.</p>
</div>
<div class="paragraph">
<p>Next, the user must choose how to parse the body, the instance, and the short witness.
The headers of the instance and short witness can be parsed similarly to the relation&#8217;s.
However, the instance and short_witness do not have <em>Gate Set</em> or <em>Feature Toggles</em>, and must defer to the <em>relation</em>.</p>
</div>
<div class="paragraph">
<p>A critical decision is whether the <em>Gate Set</em> is <a href="api/wtk/Parser.html#struct_BooleanParser"><em>Boolean</em></a> or <a href="api/wtk/Parser.html#struct_ArithmeticParser"><em>arithmetic</em></a>.
This is because the parsing API splits on these boundaries.
Another potential decision is whether or not the relation is IR-<em>Simple</em>.
WizToolKit&#8217;s parsers have a streaming API for IR-Simple, which may improve performance for some relations.
However, the streaming API cannot handle non-simple relations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #dddddd">std::string instance_name = </span><span style="color: #00ff00">/* ... */</span><span style="color: #dddddd">;</span>
<span style="color: #dddddd">std::string short_witness_name = </span><span style="color: #00ff00">/* ... */</span><span style="color: #dddddd">;</span>
<span style="color: #dddddd">wtk::irregular::Parser&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt; instance_parser(instance_name);</span>
<span style="color: #dddddd">wtk::irregular::Parser&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt; short_witness_parser(short_witness_name);</span>

<span style="color: #ff0000">if</span><span style="color: #dddddd">(!instance_parser.parseHdrResParams()</span>
<span style="color: #dddddd">    || !short_witness_parser.parseHdrResParams()</span>
<span style="color: #dddddd">    || parser.characteristic != instance_parser.characteristic</span>
<span style="color: #dddddd">    || parser.characteristic != short_witness_parser.characteristic)</span>
<span style="color: #dddddd">{</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">/* handle error */</span>
<span style="color: #dddddd">}</span>

<span style="color: #ff0000">if</span><span style="color: #dddddd">(parser.resource == wtk::Resource::relation)</span>
<span style="color: #dddddd">  &amp;&amp; parser.gateSet.gateSet == wtk::GateSet::arithmetic)</span>
<span style="color: #dddddd">{</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">// Parse arithmetic relation</span>
<span style="color: #dddddd">  wtk::AritmeticParser&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* arith_parser = parser.arithmetic();</span>

<span style="color: #dddddd">  </span><span style="color: #ff0000">if</span><span style="color: #dddddd">(parser.featureToggles.simple()) </span><span style="color: #00ff00">// select the streaming API</span>
<span style="color: #dddddd">  {</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">// See <a href="#Streaming-API">Streaming API</a></span>
<span style="color: #dddddd">  }</span>
<span style="color: #dddddd">  </span><span style="color: #ff0000">else</span>
<span style="color: #dddddd">  {</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">// See <a href="#Syntax-Tree-API">Syntax Tree API</a></span>
<span style="color: #dddddd">  }</span>
<span style="color: #dddddd">}</span>
<span style="color: #ff0000">else</span><span style="color: #dddddd"> </span><span style="color: #ff0000">if</span><span style="color: #dddddd">(parser.resource == wtk::Resource::relation)</span>
<span style="color: #dddddd">  &amp;&amp; parser.gateSet.gateSet == wtk::GateSet::boolean)</span>
<span style="color: #dddddd">{</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">// Parse boolean relation, Note that the template is dropped,</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">// because Boolean literals are always given as uint8_t.</span>
<span style="color: #dddddd">  wtk::BooleanParser* bool_parser = parser.arithmetic();</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">/* Omitted... */</span>
<span style="color: #dddddd">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Both the instance and short-witness are abstracted as streams in the SIEVE IR.
WizToolKit handles these streams through the <a href="api/wtk/Parser.html#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;</code></a> API.</p>
</div>
<div class="paragraph">
<p>The <code>wtk::InputStream&lt;Number_T&gt;</code> objects are obtained through the parser after specializing to <a href="api/wtk/Parser.html#ArithmeticParser_instance">arithmetic</a> or <a href="api/wtk/Parser.html#BooleanParser_shortWitness">boolean</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #00ff00">// Get an arithmetic parser for an instance</span>
<span style="color: #dddddd">wtk::ArithmeticParser&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* a_ins_parser = instance_parser.arithmetic();</span>
<span style="color: #dddddd">wtk::InputStream&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* a_ins = a_ins_parser-&gt;instance();</span>

<span style="color: #00ff00">// Similarly, for Boolean short witness (as an example; instance and short</span>
<span style="color: #00ff00">// witness should have the same type).</span>
<span style="color: #dddddd">wtk::BooleanParser* b_wit_parser = short_witness_parser.arithmetic();</span>
<span style="color: #dddddd">wtk::InputStream&lt;</span><span style="color: #ee82ee">uint8_t</span><span style="color: #dddddd">&gt;* b_wit = b_wit_parser-&gt;shortWitness();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a stream is obtained, its <a href="api/wtk/Parser.html#InputStream_next"><code>next(&#8230;&#8203;)</code></a> method may be called repeatedly for each element of the stream.
The return type of <code>next(&#8230;&#8203;)</code> will indicate if it succeeded, failed, or reached the end of the stream. It has a return-by-pointer argument for the stream element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd"> ins_val = 0;</span>
<span style="color: #dddddd">wtk::StreamStatus status = a_ins-&gt;next(&amp;ins_val);</span>
<span style="color: #ff0000">if</span><span style="color: #dddddd">(status == wtk::StreamStatus::end) { </span><span style="color: #00ff00">/* End of stream */</span><span style="color: #dddddd"> }</span>
<span style="color: #ff0000">else</span><span style="color: #dddddd"> </span><span style="color: #ff0000">if</span><span style="color: #dddddd">(status == wtk::StreamStatus::error) { </span><span style="color: #00ff00">/* mid-stream parser error */</span><span style="color: #dddddd"> }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of the parsers (namely <a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR</a> and <a href="api/wtk/antlr/Parser.html#api_flatbuffer_Parser">FlatBuffer</a>) will parse the entire stream up front, in which case a parser error is indicated on the first element, regardless of its place in the stream.
Other parsers (namely <a href="api/wtk/irregular/Parser.html#api_irregular_Parser">IRRegular</a>) work in a more true stream-wise fashion, reporting the error as it occurs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Streaming-API">Streaming API for Relations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Streaming API, IR-<em>Simple</em> relations are parsed one gate at a time and reported immediately.
This only works for IR-<em>Simple</em> because these relations have no nested scopes or repetition.</p>
</div>
<div class="paragraph">
<p>To report gates, the user must implement the <a href="api/wtk/ArithmeticStreamHandler.html#api_ArithmeticStreamHandler"><code>wtk::ArithmeticStreamHandler&lt;Number_T&gt;</code></a> or <a href="api/wtk/BooleanStreamHandler.html#api_BooleanStreamHandler"><code>wtk::BooleanStreamHandler</code></a> abstract class (depending on <em>Gate Set</em>, obviously).
A brief example for Arithmetic is shown here.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #ff0000">class</span><span style="color: #dddddd"> UserArithmeticStreamHandler : </span><span style="color: #ff0000">public</span><span style="color: #dddddd"> wtk::ArithmeticStreamHandler&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;</span>
<span style="color: #dddddd">{</span>
<span style="color: #dddddd">  </span><span style="color: #ee82ee">void</span><span style="color: #dddddd"> </span><span style="color: #ffff00">handleAdd</span><span style="color: #dddddd">(wtk::index_t </span><span style="color: #ff0000">const</span><span style="color: #dddddd"> out, </span><span style="color: #00ff00">// output wire-number</span>
<span style="color: #dddddd">      wtk::index_t </span><span style="color: #ff0000">const</span><span style="color: #dddddd"> left_in,        </span><span style="color: #00ff00">// left input wire-number</span>
<span style="color: #dddddd">      wtk::index_t </span><span style="color: #ff0000">const</span><span style="color: #dddddd"> right_in)       </span><span style="color: #00ff00">// right input wire-number</span>
<span style="color: #dddddd">    </span><span style="color: #ff0000">override</span>
<span style="color: #dddddd">  {</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">/* omitted */</span>
<span style="color: #dddddd">  }</span>

<span style="color: #dddddd">  </span><span style="color: #ee82ee">void</span><span style="color: #dddddd"> </span><span style="color: #ffff00">handleMul</span><span style="color: #dddddd">(wtk::index_t </span><span style="color: #ff0000">const</span><span style="color: #dddddd"> out, </span><span style="color: #00ff00">// output wire-number</span>
<span style="color: #dddddd">      wtk::index_t </span><span style="color: #ff0000">const</span><span style="color: #dddddd"> left_in,        </span><span style="color: #00ff00">// left input wire-number</span>
<span style="color: #dddddd">      wtk::index_t </span><span style="color: #ff0000">const</span><span style="color: #dddddd"> right_in)       </span><span style="color: #00ff00">// right input wire-number</span>
<span style="color: #dddddd">    </span><span style="color: #ff0000">override</span>
<span style="color: #dddddd">  {</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">/* omitted */</span>
<span style="color: #dddddd">  }</span>

<span style="color: #dddddd">  </span><span style="color: #00ff00">/* Remaining methods omitted... */</span>
<span style="color: #dddddd">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invocation for the streaming API is through the <a href="api/wtk/Parser.html#ArithmeticParser_parseStream"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code> method <code>parseStream(&#8230;&#8203;)</code></a> or <a href="api/wtk/Parser.html#BooleanParser_parseStream"><code>wtk::BooleanParser</code> method <code>parseStream(&#8230;&#8203;)</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #00ff00">// For an arithmetic simple relation</span>
<span style="color: #dddddd">UserArithmeticStreamHandler handler;</span>
<span style="color: #ff0000">if</span><span style="color: #dddddd">(!arith_parser-&gt;parseStream(&amp;handler)) { </span><span style="color: #00ff00">/* Parse Error */</span><span style="color: #dddddd"> }</span>

<span style="color: #00ff00">// For a Boolean simple relation</span>
<span style="color: #dddddd">UserBooleanStreamHandler handler;</span>
<span style="color: #ff0000">if</span><span style="color: #dddddd">(!bool_parser-&gt;parseStream(&amp;handler)) { </span><span style="color: #00ff00">/* Parse Error */</span><span style="color: #dddddd"> }</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Syntax-Tree-API">Syntax Tree API for Relations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Syntax Tree API can handle any relation, regardless of its feature set.
However, it must parse the entire relation ahead of time, and allocate a syntax tree, which for very long relations can consume a lot of memory.</p>
</div>
<div class="paragraph">
<p>The syntax tree is defined by <a href="api/wtk/IRTree.html#api_IRTree">#include &lt;wtk/IRTree.h&gt;</a>.
At a top-level it is defined by the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a>, which aggregates function definitions and the relation&#8217;s main body.
Each scope is a <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;</code></a> with the ability to retrieve gates such as <a href="api/wtk/IRTree.html#struct_BinaryGate"><code>wtk::BinaryGate</code></a> (binary referring to its cardinality) or <a href="api/wtk/IRTree.html#struct_Input"><code>wtk::Input</code></a> (for the instance or short-witness).</p>
</div>
<div class="paragraph">
<p>The Tree is again retrieved through the <a href="api/wtk/Parser.html#ArithmeticParser_parseTree"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code></a> or <a href="api/wtk/Parser.html#BooleanParser_parseTree"><code>wtk::BooleanParser</code></a> <code>parseTree()</code> method (only Arithmetic shown).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #dddddd">wtk::IRTree&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* ir_tree = arith_parser-&gt;parseTree();</span>
<span style="color: #ff0000">if</span><span style="color: #dddddd">(ir_tree == </span><span style="color: #ff0000">nullptr</span><span style="color: #dddddd">) { </span><span style="color: #00ff00">/* Parser error */</span><span style="color: #dddddd"> }</span>

<span style="color: #00ff00">// To be implemented by the user.</span>
<span style="color: #dddddd">process_ir_tree(ir_tree);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To process the relation, the user must do a tree traversal.
At a top level, the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> holds a list of function declarations (we&#8217;ll get to these later), and the relation&#8217;s main body.
The main body is just a <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;</code></a>, which is an indirectly-recursive type, defining much of the syntax tree.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #ee82ee">void</span><span style="color: #dddddd"> </span><span style="color: #ffff00">process_ir_tree</span><span style="color: #dddddd">(wtk::IRTree&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* tree)</span>
<span style="color: #dddddd">{</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">// See <a href="#Syntax-Tree-Functions">Syntax Tree API for Functions</a> for function-declarations.</span>

<span style="color: #dddddd">  </span><span style="color: #00ff00">// The circuit&#39;s entry point is its body.</span>
<span style="color: #dddddd">  process_directive_list(tree-&gt;body());</span>
<span style="color: #dddddd">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Processing the <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number-T&gt;</code></a> is a simple matter of traversing each directive in the scope, and switching on its <a href="api/wtk/IRTree.html#DirectiveList_enum_Type">type</a>.
Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #ee82ee">void</span><span style="color: #dddddd"> </span><span style="color: #ffff00">process_directive_list</span><span style="color: #dddddd">(wtk::DirectiveList&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* dir_list)</span>
<span style="color: #dddddd">{</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">// The DirectiveList is a tree type, leaf-nodes are typically gates</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">// (@and/@xor/@mul/etc.) with other nodes taking the form of higher</span>
<span style="color: #dddddd">  </span><span style="color: #00ff00">// level features.</span>

<span style="color: #dddddd">  </span><span style="color: #ff0000">for</span><span style="color: #dddddd">(</span><span style="color: #ee82ee">size_t</span><span style="color: #dddddd"> i = 0; i &lt; dir_list-&gt;size(); i++)</span>
<span style="color: #dddddd">  {</span>
<span style="color: #dddddd">    </span><span style="color: #ff0000">switch</span><span style="color: #dddddd">(dir_list-&gt;type(i))</span>
<span style="color: #dddddd">    {</span>
<span style="color: #dddddd">    </span><span style="color: #ff0000">case</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">wtk</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">DirectiveList</span><span style="color: #dddddd">&lt;</span><span style="color: #7fffd4">unsigned</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">long</span><span style="color: #dddddd">&gt;::</span><span style="color: #7fffd4">BINARY_GATE</span><span style="color: #dddddd">:</span>
<span style="color: #dddddd">    {</span>
<span style="color: #dddddd">      </span><span style="color: #00ff00">// the &quot;binary&quot; (in signature, not value) gate describes</span>
<span style="color: #dddddd">      </span><span style="color: #00ff00">// @and/@xor/@mul/@add gates.</span>
<span style="color: #dddddd">      wtk::BinaryGate* gate = dir_list-&gt;binaryGate(i);</span>
<span style="color: #dddddd">      </span><span style="color: #00ff00">// these are the input and output wire numbers of the gate</span>
<span style="color: #dddddd">      wtk::index_t left_input_wire = gate-&gt;leftWire();</span>
<span style="color: #dddddd">      wtk::index_t right_input_wire = gate-&gt;rightWire();</span>
<span style="color: #dddddd">      wtk::index_t output_wire = gate-&gt;outputWire();</span>

<span style="color: #dddddd">      </span><span style="color: #00ff00">// The gate&#39;s calculation is an enum</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">switch</span><span style="color: #dddddd">(gate-&gt;calculation())</span>
<span style="color: #dddddd">      {</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">case</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">wtk</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">BinaryGate</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">AND</span><span style="color: #dddddd">: { </span><span style="color: #ff0000">break</span><span style="color: #dddddd">; }</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">case</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">wtk</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">BinaryGate</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">XOR</span><span style="color: #dddddd">: { </span><span style="color: #ff0000">break</span><span style="color: #dddddd">; }</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">case</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">wtk</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">BinaryGate</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">ADD</span><span style="color: #dddddd">: { </span><span style="color: #ff0000">break</span><span style="color: #dddddd">; }</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">case</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">wtk</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">BinaryGate</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">MUL</span><span style="color: #dddddd">: { </span><span style="color: #ff0000">break</span><span style="color: #dddddd">; }</span>
<span style="color: #dddddd">      }</span>

<span style="color: #dddddd">      </span><span style="color: #ff0000">break</span><span style="color: #dddddd">;</span>
<span style="color: #dddddd">    }</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">/* other gate-types omitted for brevity */</span>
<span style="color: #dddddd">    </span><span style="color: #ff0000">case</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">wtk</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">DirectiveList</span><span style="color: #dddddd">&lt;</span><span style="color: #7fffd4">unsigned</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">long</span><span style="color: #dddddd">&gt;::</span><span style="color: #7fffd4">ANON_FUNCTION</span><span style="color: #dddddd">:</span>
<span style="color: #dddddd">    {</span>
<span style="color: #dddddd">      wtk::AnonFunction&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* anon_func = dir_list-&gt;anonFunction(i);</span>
<span style="color: #dddddd">      </span><span style="color: #00ff00">// The signature of the function, along with its inputs/outputs</span>
<span style="color: #dddddd">      </span><span style="color: #00ff00">// is easily retrievable.</span>
<span style="color: #dddddd">      wtk::WireList* output_wires = anon_func-&gt;outputList();</span>
<span style="color: #dddddd">      wtk::WireList* input_wires = anon_func-&gt;inputList();</span>
<span style="color: #dddddd">      wtk::index_t num_instance_vals = anon_func-&gt;instanceCount();</span>
<span style="color: #dddddd">      wtk::index_t num_witness_vals = anon_func-&gt;shortWitnessCount();</span>

<span style="color: #dddddd">      </span><span style="color: #00ff00">// To process the body of the anonymous function, use recursion.</span>
<span style="color: #dddddd">      process_directive_list(anon_func-&gt;body());</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">break</span><span style="color: #dddddd">;</span>
<span style="color: #dddddd">    }</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">/* Other feature-types omitted for brevity */</span>
<span style="color: #dddddd">    }</span>
<span style="color: #dddddd">  }</span>
<span style="color: #dddddd">}</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="Syntax-Tree-Functions">Syntax Tree API for Functions</h3>
<div class="paragraph">
<p>For IR named-functions, the body of a function and its invocation are split.
All function-declarations are listed at the top of a relation.
Correspondingly, the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> has a <a href="api/wtk/IRTree.html#IRTree_functionDeclare"><code>functionDeclare(i)</code></a> method for retrieval, and <a href="api/wtk/IRTree.html#IRTree_size"><code>size()</code></a> indicating how many may be retrieved.</p>
</div>
<div class="paragraph">
<p>For easy access, we suggest entering the function declarations into a <code>std::map</code> or <code>std::unordered_map</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #00ff00">// declare a map to hold them</span>
<span style="color: #dddddd">std::map&lt;std::string, wtk::FunctionDeclare&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;*&gt; functions_map;</span>

<span style="color: #dddddd">  </span><span style="color: #00ff00">// enter each function-declaration into the map</span>
<span style="color: #dddddd">  </span><span style="color: #ff0000">for</span><span style="color: #dddddd">(</span><span style="color: #ee82ee">size_t</span><span style="color: #dddddd"> i = 0; i &lt; tree-&gt;size(); i++)</span>
<span style="color: #dddddd">  {</span>
<span style="color: #dddddd">    wtk::FunctionDeclare&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* function = tree-&gt;functionDeclare(i);</span>

<span style="color: #dddddd">    </span><span style="color: #00ff00">// function-&gt;name() is a char* while std::map works only with std::strings</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">// with c++17, it should be okay to use std::string_view so long as</span>
<span style="color: #dddddd">    </span><span style="color: #00ff00">// *tree outlives functions_map</span>
<span style="color: #dddddd">    std::string </span><span style="color: #ffff00">name</span><span style="color: #dddddd">(function-&gt;name());</span>

<span style="color: #dddddd">    </span><span style="color: #00ff00">// check that the function wasn&#39;t previously declared</span>
<span style="color: #dddddd">    </span><span style="color: #ff0000">auto</span><span style="color: #dddddd"> finder = functions_map.find(name);</span>
<span style="color: #dddddd">    </span><span style="color: #ff0000">if</span><span style="color: #dddddd">(finder != functions_map.end()) { </span><span style="color: #00ff00">/* Error */</span><span style="color: #dddddd"> }</span>

<span style="color: #dddddd">    functions_map[name] = function;</span>
<span style="color: #dddddd">  }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a function is invoked (with a <a href="api/wtk/IRTree.html#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a> directive), its is now just a matter of looking up its name in the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight" style="background: #000000; color: #dddddd"><code data-lang="c++"><span></span><span style="color: #dddddd">    </span><span style="color: #ff0000">case</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">wtk</span><span style="color: #dddddd">::</span><span style="color: #7fffd4">DirectiveList</span><span style="color: #dddddd">&lt;</span><span style="color: #7fffd4">unsigned</span><span style="color: #dddddd"> </span><span style="color: #7fffd4">long</span><span style="color: #dddddd">&gt;::</span><span style="color: #7fffd4">FUNCTION_INVOKE</span><span style="color: #dddddd">:</span>
<span style="color: #dddddd">    {</span>
<span style="color: #dddddd">      wtk::FunctionInvoke* invoke = dir_list-&gt;functionInvoke(i);</span>

<span style="color: #dddddd">      std::string </span><span style="color: #ffff00">name</span><span style="color: #dddddd">(invoke-&gt;name());</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">auto</span><span style="color: #dddddd"> finder = functions_map.find(name);</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">if</span><span style="color: #dddddd">(finder == functions_map.end()) { </span><span style="color: #00ff00">/* Error */</span><span style="color: #dddddd"> }</span>

<span style="color: #dddddd">      wtk::FunctionDeclare&lt;</span><span style="color: #ee82ee">unsigned</span><span style="color: #dddddd"> </span><span style="color: #ee82ee">long</span><span style="color: #dddddd">&gt;* declaration = finder-&gt;second;</span>

<span style="color: #dddddd">      </span><span style="color: #00ff00">// To process the body of the function, use recursion.</span>
<span style="color: #dddddd">      process_directive_list(declaration-&gt;body());</span>
<span style="color: #dddddd">      </span><span style="color: #ff0000">break</span><span style="color: #dddddd">;</span>
<span style="color: #dddddd">    }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information about the IR Syntax Tree, See <a href="api/wtk/IRTree.html#api_IRTree"><code>#include &lt;wtk/IRTree.h&gt;</code></a>.</p>
</div>
</div>
</div>
</div>
</main>

    <footer>
      
        <p id="distributionStatement">
          <strong>Distribution Statement A:</strong> Approved for Public Release, Distribution Unlimited.
        </p>
      
      <p>
        Copyright &copy; 2023, Stealth Software Technologies, Inc.
        All Rights Reserved.
      </p>
      
        <p id="acknowledgement">
          This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087. The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
        </p>
      

      <a href="https://www.stealthsoftwareinc.com" id="bottomLogoImg">
        <img
          src="/wiztoolkit/assets/icons/tetra-solid-400x100.png"
          alt="Stealth Software Technologies Home Page" /></a>

      
    </footer>
  </body>
</html>

