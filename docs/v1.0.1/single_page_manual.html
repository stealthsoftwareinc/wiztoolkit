<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WizToolKit Manual - WizToolKit</title>
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/fonts.css" />
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/layout.css" />
    <link rel="stylesheet"
        href="/wiztoolkit/assets/css/content.css" />

    <link rel="shortcut icon" type="image/png"
        href="/wiztoolkit/assets/icons/tetra-solid-32x32.png" />

    <link type="application/atom+xml" rel="alternate" href="https://stealthsoftwareinc.github.io/wiztoolkit/feed.xml" title="WizToolKit" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>WizToolKit Manual | WizToolKit</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="WizToolKit Manual" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/single_page_manual.html" />
<meta property="og:url" content="https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/single_page_manual.html" />
<meta property="og:site_name" content="WizToolKit" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="WizToolKit Manual" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"WizToolKit Manual","url":"https://stealthsoftwareinc.github.io/wiztoolkit/docs/v1.0.1/single_page_manual.html"}</script>
<!-- End Jekyll SEO tag -->


    <script>0</script>
  </head>
  <body>
    <header>
      <nav id="topNav">
        <a href="#main" id="jumpMain">Jump to Main</a>
        <a href="https://www.stealthsoftwareinc.com" id="logoImg">
          <img
            src="/wiztoolkit/assets/icons/tetra-solid-100x100.png"
            alt="Stealth Software Technologies Home Page" /></a>
        <a href="/wiztoolkit/" id="titleLink">WizToolKit</a>
        <span id="spacer">&nbsp;</span>
        
          
            <a href="/wiztoolkit/"
              
              >about</a>
          
        
          
            <a href="/wiztoolkit/docs/v2.1.0/"
              
              >docs</a>
          
        
          
            <a href="https://github.com/stealthsoftwareinc/wiztoolkit"
              
              >source</a>
          
        
      </nav>
    </header>
    <nav id=docsNav>
  <div>
    <h2 class="eyebrow">Docs Nav</h2>
    <p>
      <label for="version_select">Change Version:</label> <select name="version_select" onchange="location = this.value;"><option  value="/wiztoolkit/docs/v2.1.0/">v2.1.0</option><option selected value="/wiztoolkit/docs/v1.0.1/">v1.0.1</option></select>
    </p>

    
    <ul><li><a href="/wiztoolkit/docs/v1.0.1/">WizToolKit</a><ul><li>api<ul><li>wtk<ul><li>antlr<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/antlr/Parser.html">ANTLR Parser API</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/ArithmeticStreamHandler.html">Arithmetic Stream Handler API</a></li><li>bolt<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/ArithmeticPLASMASnoozeHandler.html">Arithmetic PLASMASnooze Streaming API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Backend.html">BOLT Backend API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/BooleanPLASMASnoozeHandler.html">Boolean PLASMASnooze Streaming API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Builder.html">BOLT Builder API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/Evaluator.html">BOLT Evaluator API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/bolt/PLASMASnooze.html">PLASMASnooze</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/BooleanStreamHandler.html">Boolean Stream Handler API</a></li><li>flatbuffer<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/flatbuffer/Parser.html">FlatBuffer Parser API</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/IRParameters.html">IRParameters API</a></li><li>irregular<ul><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/irregular/Parser.html">IRRegular Parser API</a></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/IRTree.html">IR Tree API</a></li><li><a href="/wiztoolkit/docs/v1.0.1/api/wtk/Parser.html">Parser API</a></li></ul></li></ul></li><li><a href="/wiztoolkit/docs/v1.0.1/backends.html">WizToolKit for Backends</a></li><li><a href="/wiztoolkit/docs/v1.0.1/commandline.html">WizToolKit on the Command-Line</a></li><li><a href="/wiztoolkit/docs/v1.0.1/install.html">Installing WizToolKit</a></li><li><a href="/wiztoolkit/docs/v1.0.1/parsers.html">Parsing the IR</a></li><li class="curr_page"><a href="/wiztoolkit/docs/v1.0.1/single_page_manual.html">WizToolKit Manual</a>
      <ul class="sectlevel1">
<li><a href="#wiztoolkit">WizToolKit</a>
<ul class="sectlevel2">
<li><a href="#command-line">Command-line</a></li>
<li><a href="#parsing-the-ir">Parsing the IR</a></li>
<li><a href="#for-zk-backends">For ZK Backends</a></li>
<li><a href="#other-apis">Other APIs</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#licensing">Licensing</a></li>
</ul>
</li>
<li><a href="#install">Installing WizToolKit</a>
<ul class="sectlevel2">
<li><a href="#linux-and-unix-derivitives">Linux and Unix derivitives</a></li>
<li><a href="#windows-10">Windows 10</a></li>
<li><a href="#generic-build-guide">Generic Build Guide</a></li>
</ul>
</li>
<li><a href="#commandline">WizToolKit on the Command-Line</a>
<ul class="sectlevel2">
<li><a href="#tools_firealarm">FIREALARM (Checking and Evaluating)</a></li>
<li><a href="#tools_press">PRESS (Format and Feature Conversion)</a></li>
<li><a href="#tools_viz">Viz (Visualization)</a></li>
<li><a href="#tools_bolt">BOLT (Example and Testing)</a></li>
</ul>
</li>
<li><a href="#parsers">Parsing the IR</a>
<ul class="sectlevel2">
<li><a href="#numbers-in-the-ir">Numbers in the IR</a></li>
<li><a href="#parsing-options">Parsing Options</a></li>
<li><a href="#parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</a></li>
<li><a href="#Streaming-API">Streaming API for Relations</a></li>
<li><a href="#Syntax-Tree-API">Syntax Tree API for Relations</a></li>
</ul>
</li>
<li><a href="#backends">WizToolKit for Backends</a>
<ul class="sectlevel2">
<li><a href="#numeric-representations">Numeric Representations</a></li>
<li><a href="#the-backend-api">The Backend API</a></li>
<li><a href="#invoking-bolt">Invoking BOLT</a></li>
<li><a href="#invoking-plasmasnooze">Invoking PLASMASnooze</a></li>
</ul>
</li>
<li><a href="#appendix-a-api-documentation">Appendix A: API Documentation</a>
<ul class="sectlevel2">
<li><a href="#api_Parser">Parser API</a></li>
<li><a href="#api_IRTree">IR Tree API</a></li>
<li><a href="#api_IRParameters">IRParameters API</a></li>
<li><a href="#api_ArithmeticStreamHandler">Arithmetic Stream Handler API</a></li>
<li><a href="#api_BooleanStreamHandler">Boolean Stream Handler API</a></li>
<li><a href="#api_antlr_Parser">ANTLR Parser API</a></li>
<li><a href="#api_irregular_Parser">IRRegular Parser API</a></li>
<li><a href="#api_flatbuffer_Parser">FlatBuffer Parser API</a></li>
<li><a href="#api_bolt_Builder">BOLT Builder API</a></li>
<li><a href="#api_bolt_Evaluator">BOLT Evaluator API</a></li>
<li><a href="#api_bolt_Backend">BOLT Backend API</a></li>
<li><a href="#api_bolt_PLASMASnooze">PLASMASnooze</a></li>
<li><a href="#api_bolt_ArithmeticPLASMASnoozeHandler">Arithmetic PLASMASnooze Streaming API</a></li>
<li><a href="#api_bolt_BooleanPLASMASnoozeHandler">Boolean PLASMASnooze Streaming API</a></li>
</ul>
</li>
</ul>
    </li><li>tools<ul><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-bolt.html">BOLT (Example and Testing)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-firealarm.html">FIREALARM (Checking and Evaluating)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-press.html">PRESS (Format and Feature Conversion)</a></li><li><a href="/wiztoolkit/docs/v1.0.1/tools/wtk-viz.html">Viz (Visualization)</a></li></ul></li></ul></li></ul>
  </div>
</nav>

<main id="main" tabindex="-1">
  <h1>WizToolKit Manual</h1>
  <div class="sect1">
<h2 id="wiztoolkit">WizToolKit</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a collection of tools, provided by team Wizkit, for working with the SIEVE IR.
It In addition to a few command-line tools, it has an extensive C++ API for manipulating the SIEVE IR.
This release of WizToolKit corresponds to version <code>1.0.0</code> of the SIEVE IR Specification.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re not familiar with the SIEVE IR, have a look at our <a href="https://stealthsoftwareinc.github.io/wizkit-blog/2021/09/20/introducing-the-sieve-ir.html">introduction to the SIEVE IR</a>.
It represents ZK relations using circuits, and the instance and short-witness as input streams.</p>
</div>
<div class="sect2">
<h3 id="command-line">Command-line</h3>
<div class="paragraph">
<p>The following tools are available on the command-line from WizToolKit.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk-firealarm</code> (checking and evaluating)</dt>
<dd>
<p>Checks an individual IR resource for well-formedness. For a triple of relation, instance, and short-witness it checks for evaluation validity.</p>
</dd>
<dt class="hdlist1"><code>wtk-press</code> (format and feature conversions)</dt>
<dd>
<p>Converts between the text and binary formats of the IR. It can also replace IR <code>@switch</code> directives with a <em>multiplexer</em> implementation using <code>@loop</code>s and a <code>@function</code>.</p>
</dd>
<dt class="hdlist1"><code>wtk-viz</code> (visualization)</dt>
<dd>
<p>Visualize the IR by converting it to <a href="https://graphviz.org/">Graphviz</a>.</p>
</dd>
<dt class="hdlist1"><code>wtk-bolt</code> (example and testing)</dt>
<dd>
<p>Invokes the BOLT or PLASMASnooze interpreters without ZK. For use in testing or as an example. See <a href="backends.html#backends">WizToolKit for Backends</a> for more information on these.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For more information on these tools see <a href="commandline.html#commandline">WizToolKit on the command-line</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="parsing-the-ir">Parsing the IR</h3>
<div class="paragraph">
<p>WizToolKit enables parsing both text and binary profiles of the SIEVE IR.
The parsing API is designed for maximal flexibility, parsing the header first and then allowing the user to decide how to proceed.</p>
</div>
<div class="paragraph">
<p>In addition to both IR-Formats, WizToolKit can parse a resource with either a streaming parser (when grammar is limited to IR-Simple) or a syntax-tree parser.
It also allows the user to supply a numeric type for parsing field-element literals via a template parameter, and after parsing the header to possibly downgrade to <code>uint64_t</code> or <code>uint32_t</code> for the remaining IR body.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parser</th>
<th class="tableblock halign-left valign-top">Format</th>
<th class="tableblock halign-left valign-top">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANTLR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses the <a href="https://www.antlr.org/">ANTLR generator</a>. "Obviously" correct, parses line-numbers, slow</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IRRegular</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fast, minimal memory use, no line-numbers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FlatBuffer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://google.github.io/flatbuffers">FlatBuffer</a> parser</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For more information see <a href="parsers.html#parsers">Parsing the IR</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="for-zk-backends">For ZK Backends</h3>
<div class="paragraph">
<p>For ZK Backends, WizToolKit provides a simple Backend API, and two interpreters to drive the API.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">BOLT</dt>
<dd>
<p>first builds an augmented representation of the relation while checking for well-formedness. Then it evaluates without needing any well-formedness checks or having to stop and translate indices to actual wires. This is ideal for relations which make heavy use of loops.</p>
</dd>
<dt class="hdlist1">PLASMASnooze</dt>
<dd>
<p>(A pun on FIREALARM) simply traverses the IR syntax-tree doing on-the-fly well-formedness checks.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For more information see <a href="backends.html#backends">WizToolKit for ZK Backends</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="other-apis">Other APIs</h3>
<div class="paragraph">
<p>The entirety of the WizToolKit command-line is available as API, however not all of it is well documented.</p>
</div>
</div>
<div class="sect2">
<h3 id="building">Building</h3>
<div class="paragraph">
<p>WizToolKit uses CMake, Python3, Java (optional), and a number of other utilities during build, of course in addition to a C++ compiler.
This all is orchestrated using <code>make</code>, and the familiar pattern should work.
Build artifacts are typically deposited in the <code>target/</code> directoy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">make</span>
<span class="tok-n">make</span><span class="tok-w"> </span><span class="tok-n">install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="install.html#install">Install Guide</a> for details, and for a list of necessary dependencies.</p>
</div>
</div>
<div class="sect2">
<h3 id="licensing">Licensing</h3>
<div class="paragraph">
<p>The source code and other substantial material in this directory is Copyright &#169; 2020-2022 Stealth Software Technologies, Inc.</p>
</div>
<div class="paragraph">
<p>This version of WizToolKit has been approved for public release under the open-source <a href="license.md">MIT License</a>.</p>
</div>
<div class="paragraph">
<p><strong>Distribution Statement A</strong>: Approved for Public Release, Distribution Unlimited.</p>
</div>
<div class="paragraph">
<p>This material is based upon work supported by DARPA under Contract No. HR001120C0087.  Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of DARPA.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="install">Installing WizToolKit</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="linux-and-unix-derivitives">Linux and Unix derivitives</h3>
<div class="paragraph">
<p>We&#8217;ve compiled a list of installation instructions for a few common systems.</p>
</div>
<div class="sect3">
<h4 id="redhatcentos-streamrockyalma-8">RedHat/CentOS-Stream/Rocky/Alma 8</h4>
<div class="paragraph">
<p>These systems are regularly tested by CI.
Starting from a 'minimal installation', You will need to install these dependencies with <code>yum</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>yum<span class="tok-w"> </span>install<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>epel-release<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>yum-utils
yum<span class="tok-w"> </span>config-manager<span class="tok-w"> </span>--set-enabled<span class="tok-w"> </span>powertools
yum<span class="tok-w"> </span>install<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>git<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>tar<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>make<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>wget<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>unzip<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>cmake<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>libuuid<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>libuuid-devel<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>gcc-c++<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>diffutils<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>which<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>java-11-openjdk-devel<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>java-11-openjdk-headless<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>python39<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>openssl<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>openssl-devel</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once installed, you can invoke make as normal.
Keep in mind, that <code>make</code> will download additional dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>make
make<span class="tok-w"> </span>install</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redhatcentos-7">RedHat/CentOS 7</h4>
<div class="paragraph">
<p>These systems are tested regularly in CI, however the <a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR parser</a> does not build due to differences in C++ dialects.
Starting with a 'minimal installation' You will need to install these dependencies with <code>yum</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>yum<span class="tok-w"> </span>install<span class="tok-w"> </span>epel-release
yum<span class="tok-w"> </span>install<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>git<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>tar<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>make<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>wget<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>unzip<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>cmake3<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>libuuid<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>libuuid-devel<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>gcc-c++<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>diffutils<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>which<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>java-11-openjdk-devel<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>java-11-openjdk-headless<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>python3<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>openssl<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>openssl-devel</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use <code>make</code>, you will need to disable ANTLR.
Keep in mind, that <code>make</code> will download additional dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>make<span class="tok-w"> </span><span class="tok-nv">ENABLE_ANTLR</span><span class="tok-o">=</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-nv">CMAKE_CMD</span><span class="tok-o">=</span>cmake3
make<span class="tok-w"> </span>install</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ubuntu-18-04-lts">Ubuntu 18.04 LTS</h4>
<div class="paragraph">
<p>This platform is regularly tested in CI. To install dependencies</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>apt-get<span class="tok-w"> </span>install<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>git<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>build-essential<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>make<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>wget<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>unzip<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>cmake<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>g++<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>uuid-dev<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>default-jdk<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>python3<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>libssl-dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Build is as normal.
Keep in mind, that <code>make</code> will download additional dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>make
make<span class="tok-w"> </span>install</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ubuntu-20-04-lts">Ubuntu 20.04 LTS</h4>
<div class="paragraph">
<p>This platform is regularly tested in CI. To install dependencies</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>apt-get<span class="tok-w"> </span>install<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>git<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>build-essential<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>make<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>wget<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>unzip<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>cmake<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>g++<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>uuid-dev<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>default-jdk<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>python3<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>libssl-dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Build is as normal.
Keep in mind, that <code>make</code> will download additional dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>make
make<span class="tok-w"> </span>install</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="windows-10">Windows 10</h3>
<div class="paragraph">
<p>We are not able to regularly test this platform as of yet, but we do some manual testing on occasion.
We find that windows builds are best done within the <a href="https://www.msys2.org">MSYS2&#8217;s</a> MinGW64 environment.
After installing MSYS2, launch <em>"MSYS2 MinGW 64-bit"</em> from the "start-button".</p>
</div>
<div class="paragraph">
<p>To install the necessary dependencies use <code>pacman</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>pacman<span class="tok-w"> </span>-S<span class="tok-w"> </span>--needed<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>tar<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>git<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>wget<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>make<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>unzip<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>diffutil<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>mingw-w64-x86_64-gcc<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>mingw-w64-x86_64-make<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>mingw-w64-x86_64-cmake<span class="tok-w"> </span><span class="tok-se">\</span>
<span class="tok-w">  </span>mingw-w64-x86_64-openssl</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you will need to invoke <code>make</code> with the correct variables.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR</a> doesn&#8217;t compile in MSYS2 because Java doesn&#8217;t exist.</p>
</li>
<li>
<p><code>make</code> should be invoked as normal, but when it invokes make it should use <code>mingw32-make</code>.</p>
</li>
<li>
<p>CMake should use the <code>'MinGW Makefiles'</code> generator.</p>
</li>
<li>
<p>The C compiler should be `/mingw64/bin/x86_64-w64-mingw32-g.exe`</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To do all this, the following <code>make</code> command is best.
Keep in mind, that <code>make</code> will download additional dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>make<span class="tok-w"> </span><span class="tok-nv">ENABLE_ANTLR</span><span class="tok-o">=</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-nv">MAKE_CMD</span><span class="tok-o">=</span>mingw32-make<span class="tok-w"> </span><span class="tok-nv">CMAKE_GENERATOR</span><span class="tok-o">=</span><span class="tok-s1">&#39;MinGW Makefiles&#39;</span><span class="tok-w"> </span><span class="tok-nv">CXX</span><span class="tok-o">=</span>/mingw64/bin/x86_64-w64-mingw32-g++.exe
make<span class="tok-w"> </span><span class="tok-nv">ENABLE_ANTLR</span><span class="tok-o">=</span><span class="tok-m">0</span><span class="tok-w"> </span><span class="tok-nv">MAKE_CMD</span><span class="tok-o">=</span>mingw32-make<span class="tok-w"> </span><span class="tok-nv">CMAKE_GENERATOR</span><span class="tok-o">=</span><span class="tok-s1">&#39;MinGW Makefiles&#39;</span><span class="tok-w"> </span><span class="tok-nv">CXX</span><span class="tok-o">=</span>/mingw64/bin/x86_64-w64-mingw32-g++.exe<span class="tok-w"> </span>install</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use WizToolKit commandline tools beyond the realm of MSYS2, (for example from <code>cmd.exe</code>) you will need to add to your <code>PATH</code>.
Then you can invoke <code>wtk-</code> commands by their absolute path (or add their path to the <code>PATH</code> as well).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span><span class="tok-nv">PATH</span><span class="tok-o">=</span>%PATH%<span class="tok-p">;</span>C:<span class="tok-se">\m</span>sys64<span class="tok-se">\m</span>ingw64<span class="tok-se">\b</span>in<span class="tok-p">;</span>C:<span class="tok-se">\m</span>sys64<span class="tok-se">\m</span>ingw64<span class="tok-se">\l</span>ib
C:<span class="tok-se">\m</span>sys64<span class="tok-se">\u</span>sr<span class="tok-se">\l</span>ocal<span class="tok-se">\b</span>in<span class="tok-se">\w</span>tk-firealarm.exe</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generic-build-guide">Generic Build Guide</h3>
<div class="sect3">
<h4 id="dependencies">Dependencies</h4>
<div class="paragraph">
<p>The build system for WizToolKit depends on a number of tools.
See also the WizToolKit <a href="./sbom.spdx">Software Bill-of-Materials</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>GNU Make: for task orchestration</p>
</li>
<li>
<p>CMake: for C++ build orchestration</p>
</li>
<li>
<p>C++ Compiler (tested against <code>g++</code> and <code>clang++</code>)</p>
</li>
<li>
<p><code>wget</code>: for downloading dependencies</p>
</li>
<li>
<p>Java Runtime 1.8 (or higher): for running the ANTLR tool (required only at build time)</p>
</li>
<li>
<p>Python 3: for generating portions of the IRRegular text parser (required only at build time).</p>
</li>
<li>
<p><code>pkg-config</code>: is required by CMake, and apparently not always installed by default on Ubuntu.</p>
</li>
<li>
<p>OpenSSL libcrypto and <code>sst::bignum</code>:</p>
<div class="ulist">
<ul>
<li>
<p>OpenSSL should be provided by the system.</p>
</li>
<li>
<p><code>sst::bignum</code> is downloaded automatically.</p>
</li>
<li>
<p>Only the WizToolKit <a href="commandline.html#commandline"><em>command line tools</em></a> use the unlimited precision number library <code>openssl/bn.h</code> and C++ wrapper <code>sst::bignum</code>.</p>
</li>
<li>
<p>the WizToolKit <em>API</em> <strong>does not</strong> link to these library.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://www.antlr.org/">ANTLR 4</a>: for generating and running the <a href="api/wtk/antlr/Parser.html#api_antlr_Parser"><code>wtk/antlr/Parser.h</code></a> parser implementation.</p>
<div class="ulist">
<ul>
<li>
<p>downloaded automatically at build time.</p>
</li>
<li>
<p>the runtime may require the <code>libuuid-devel</code> package (or equivalent from your system&#8217;s package manager).</p>
</li>
<li>
<p>may be disabled with <code>make ENABLE_ANTLR=0</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://google.github.io/flatbuffers">FlatBuffers 2.0.0</a>: to implement the binary format of the IR specification via the <a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser">FlatBuffer Parser</a>.</p>
<div class="ulist">
<ul>
<li>
<p>may be disabled with <code>make ENABLE_FLATBUFFER=0</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Stealth logging: For reporting errors and other conditions at runtime.</p>
<div class="ulist">
<ul>
<li>
<p>this is used by the WizToolKit API.</p>
</li>
<li>
<p>downloaded automatically at build time.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://google.github.io/googletest/">Google Test</a>: for running unit tests.</p>
<div class="ulist">
<ul>
<li>
<p>downloaded automatically at build time.</p>
</li>
<li>
<p>Only used during testing.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="make-targets-and-options">Make Targets and Options</h4>
<div class="paragraph">
<p>After downloading  or <code>git clone</code>ing a WizToolKit package, to quickly install run the following commands.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span><span class="tok-w"> </span>&gt;<span class="tok-w"> </span>make
<span class="tok-w"> </span>&gt;<span class="tok-w"> </span>make<span class="tok-w"> </span>install<span class="tok-w"> </span><span class="tok-c1"># as root</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The makefile has the following more specific targets,</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>deps</code>: calls scripts to download all the non-system dependencies.</p>
</li>
<li>
<p><code>gen_parser</code>: calls scripts which do code-generation for the parser implementations.</p>
</li>
<li>
<p><code>configure</code>: calls CMake to configure the C++ build system. The following environment variables are respected.</p>
<div class="ulist">
<ul>
<li>
<p><code>BUILD_TYPE</code>: indicates whether to use <code>Debug</code> or <code>Release</code> mode. Defaults to <code>Release</code>.</p>
</li>
<li>
<p><code>PREFIX</code>: is the installation prefix to use when calling <code>install</code>. Defaults to <code>/usr/local</code>.</p>
</li>
<li>
<p><code>CXX</code>: to change the compiler</p>
</li>
<li>
<p><code>ENABLE_ANTLR</code>: enables compile of the <a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR parser</a>, otherwise only IRRegular is produced. (default 1)</p>
</li>
<li>
<p><code>ENABLE_FLATBUFFER</code>: enables compile of the <a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser">FlatBuffer parser</a> (default 1).</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>build</code>: calls CMake generate make files.</p>
</li>
<li>
<p><code>test</code>: (default target) will run the unit tests.</p>
</li>
<li>
<p><code>install</code>: installs all WizToolKit files to the system.</p>
</li>
<li>
<p><code>clean</code>: will remove all build files.</p>
</li>
<li>
<p><code>deps-clean</code>: will remove all dependencies.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="commandline">WizToolKit on the Command-Line</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="tools_firealarm">FIREALARM (Checking and Evaluating)</h3>
<div class="paragraph">
<p>FIREALARM stands for <strong>F</strong>riendly <strong>IR</strong> <strong>E</strong>valuator <strong>A</strong>nd <strong>L</strong>ogic <strong>A</strong>ssertion and <strong>R</strong>ejection <strong>M</strong>achine, it checks and evaluates IR resources without ZK.
Its intention is to be as obviously compliant with the <a href="https://github.com/sieve-zk/ir/raw/main/v1.0.1/sieve-ir-v1.0.1.pdf">IR Specification</a> as possible.
When given a relation, <code>wtk-firealarm</code> will also print gate counts before completion.</p>
</div>
<div class="paragraph">
<p>When given a single resource <code>wtk-firealarm</code> will checks for well-formedness.
For a relation, this means that each wire is assigned before it is used, and that it is never reused ("topological ordering", and "single static assignment (SSA)").
For an instance or short witness, this simply means that each value in the stream is a field-element (e.g. does not exceed the field&#8217;s characteristic).</p>
</div>
<div class="paragraph">
<p>When given all three resources, <code>wtk-firealarm</code> will evaluate the relation with the instance and short witness, indicating if the proof should be valid or not (evaluation validity).
It can also generate a program trace at two levels of detail.</p>
</div>
<div class="paragraph">
<p><code>wtk-firealarm</code> and other WizToolKit utilities may identify resource types using the following file-suffixes.
Although the IR Specification calls for all binary resources to be identified by a <code>.sieve</code> extension (when applicable), WizToolKit uses these suffixes instead.
The IR Specification does not prescribe any file-suffixes for text resources.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>*.rel</code>
</td>
<td class="hdlist2">
<p>relation</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>*.ins</code>
</td>
<td class="hdlist2">
<p>instance</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>*.wit</code>
</td>
<td class="hdlist2">
<p>short witness</p>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="command-line-optionsflags">Command-Line Options/Flags</h4>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>-i</code>
</td>
<td class="hdlist2">
<p>Use the <a href="api/wtk/irregular/Parser.html#api_irregular_Parser">IRRegular text parser</a>, instead of the <a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR text parser</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-f</code>
</td>
<td class="hdlist2">
<p>Use the <a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser">FlatBuffer binary parser</a>, instead of the ANTLR text parser. This option is required in order to check binary resources.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-t</code>
</td>
<td class="hdlist2">
<p>Produces a "light" trace, showing function-boundaries, instance and witness values, and assertions. <code>wtk-firealarm</code> must be invoked with all three resources for this to take affect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-T</code>
</td>
<td class="hdlist2">
<p>Produces a "heavy" trace, all wire assignments, in addition to a "light" trace. <code>wtk-firealarm</code> must be invoked with all three resources for this to take affect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-h</code> or <code>--help</code>
</td>
<td class="hdlist2">
<p>Print the help text.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-v</code> or <code>--version</code>
</td>
<td class="hdlist2">
<p>Print the version text.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="example-invocations">Example Invocations</h4>
<div class="paragraph">
<p>To check a relation, instance, or witness for well-formedness.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>wtk-firealarm<span class="tok-w"> </span>relation_file.rel
wtk-firealarm<span class="tok-w"> </span>instance_file.ins
wtk-firealarm<span class="tok-w"> </span>witness_file.wit</code></pre>
</div>
</div>
<div class="paragraph">
<p>To check all three for evaluation validity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>wtk-firealarm<span class="tok-w"> </span>relation_file.rel<span class="tok-w"> </span>instance_file.ins<span class="tok-w"> </span>witness_file.wit</code></pre>
</div>
</div>
<div class="paragraph">
<p>To check with binary IR.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>wtk-firealarm<span class="tok-w"> </span>-f<span class="tok-w"> </span>bin_relation_file.rel<span class="tok-w"> </span>bin_instance_file.ins<span class="tok-w"> </span>bin_witness_file.wit</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tools_press">PRESS (Format and Feature Conversion)</h3>
<div class="paragraph">
<p>PRESS, as in printing-press, is short for <strong>P</strong>rinting and <strong>R</strong>epresentation <strong>E</strong>xchange <strong>S</strong>oftware <strong>S</strong>uite.
<code>wtk-press</code> is a tool for changing the format of the IR or to remove unwanted features from the IR.
Press can convert between the text and binary formats of the IR, or it can replace <code>@switch</code> directives with a multiplexer.
The multiplexer is composed with <code>@for</code> loops, and a <code>@function(check_case, &#8230;&#8203;.)</code>, which does have to exponentiate by <em>p-1</em> when using arithmetic gates.</p>
</div>
<div class="sect3">
<h4 id="command-line-modes">Command-Line Modes</h4>
<div class="paragraph">
<p><code>wtk-press</code> uses a <code>&lt;mode&gt; &lt;input-file&gt; [ &lt;output-file&gt; ]</code> format on its command line.
Available modes are as follows.
Text parsing is always done with <a href="api/wtk/irregular/Parser.html#api_irregular_Parser">IRRegular</a>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>b2b</code>
</td>
<td class="hdlist2">
<p>Binary to binary</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>b2mux</code>
</td>
<td class="hdlist2">
<p>Binary to binary, with multiplex converter (if necessary)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>b2t</code>
</td>
<td class="hdlist2">
<p>Binary to text</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>t2b</code>
</td>
<td class="hdlist2">
<p>Text to binary</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>t2mux</code>
</td>
<td class="hdlist2">
<p>Text to text, with multiplex converter (if necessary)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>t2t</code>
</td>
<td class="hdlist2">
<p>Text to text</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It also has some more testing oriented modes, which convert to nothing.
Essentially they are for testing and profiling the <a href="parsers.html#parsers">parsers</a>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>a2n</code>
</td>
<td class="hdlist2">
<p><a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR</a> to nothing</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>b2n</code>
</td>
<td class="hdlist2">
<p><a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser">Binary</a> to nothing</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>t2n</code>
</td>
<td class="hdlist2">
<p><a href="api/wtk/irregular/Parser.html#api_irregular_Parser">Text (IRRegular)</a> to nothing</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="example-invocations-2">Example invocations</h4>
<div class="paragraph">
<p>To convert from a text file to a binary file, or reverse.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>wtk-press<span class="tok-w"> </span>t2b<span class="tok-w"> </span>relation_file.rel<span class="tok-w"> </span>bin_relation_file.rel
wtk-press<span class="tok-w"> </span>b2t<span class="tok-w"> </span>bin_relation_file.rel<span class="tok-w"> </span>&gt;<span class="tok-w"> </span>relation_file_copy.rel</code></pre>
</div>
</div>
<div class="paragraph">
<p>To remove the <code>@switch</code> features.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>wtk-press<span class="tok-w"> </span>t2mux<span class="tok-w"> </span>relation_file.rel<span class="tok-w"> </span>relation_file_mux.rel
wtk-press<span class="tok-w"> </span>b2mux<span class="tok-w"> </span>bin_relation_file.rel<span class="tok-w"> </span>bin_relation_file_mux.rel</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tools_viz">Viz (Visualization)</h3>
<div class="paragraph">
<p>For assistance in visualizing the IR, we came up with an IR to <a href="https://graphviz.org">Graphviz</a> converter (called <code>wtk-viz</code>).
<code>wtk-viz</code> expects its input to be a relation, and produces a <em>dot</em> graph as output.
It traverses the IR Syntax Tree, and in most cases makes a fairly naive translation into the Dot language.
In the case of for-loops, <code>wtk-viz</code> repeats the loop scope mappings for each iteration of the loop, as it shows a better picture of the web created by repeated mappings.</p>
</div>
<div class="sect3">
<h4 id="command-line-usage">Command Line Usage</h4>
<div class="paragraph">
<p><code>wtk-viz</code> accepts arguments in a <code>[ options&#8230;&#8203; ] &lt;input.rel&gt; [ &lt;output.rel&gt; ]</code> form.
These are the available options.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>--fg &lt;color&gt;</code>
</td>
<td class="hdlist2">
<p>Changes the color of nodes, edges, and text ("foreground") to the given HTML color.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>--bg &lt;color&gt;</code>
</td>
<td class="hdlist2">
<p>Changes the color of the background to the given HTML color.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-f</code>
</td>
<td class="hdlist2">
<p>Use <a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser">FlatBuffers</a> to parse the binary relation (defaults to <a href="api/wtk/irregular/Parser.html#api_irregular_Parser">Text/IRRegular</a>).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-h</code> or <code>--help`</code>
</td>
<td class="hdlist2">
<p>Print the help text.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>-v</code> or <code>--version`</code>
</td>
<td class="hdlist2">
<p>Print the version information.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="example-invocations-3">Example invocations</h4>
<div class="paragraph">
<p><code>wtk-viz</code> is invoked first to produce <em>dot</em> source, followed by the <code>dot</code> compiler to generate an image.
<code>dot</code> invocation may take a long time for large circuits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>wtk-viz<span class="tok-w"> </span>relation_file.rel<span class="tok-w"> </span>relation_graph.dot
dot<span class="tok-w"> </span>-Tsvg<span class="tok-w"> </span>relation_graph.dot<span class="tok-w"> </span>-o<span class="tok-w"> </span>relation_graph.svg</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tools_bolt">BOLT (Example and Testing)</h3>
<div class="paragraph">
<p>WizToolKit delivers the <code>wtk::bolt</code> API for implementing ZK Backends in the IR.
The <code>wtk-bolt</code> command-line tool serves for testing this API in a <em>non-ZK</em> and as an example of invoking the <code>wtk::bolt</code> API.
More information may be found in <a href="backends.html#backends">WizToolKit for Backends</a>.</p>
</div>
<div class="paragraph">
<p><code>wtk::bolt</code> implements two intepreters, BOLT for relations with heavy use of loops and PLASMASnooze for relations which are largely IR-Simple.
PLASMASnooze also implements the Parser&#8217;s <a href="parsers.html#Streaming-API">streaming API</a> for additional performance when parsing IR-Simple (rather than nearly simple).
Invocation is <code>wtk-bolt [ bolt | plasmasnooze | stream ] &lt;relation.rel&gt; &lt;instance.ins&gt; &lt;witness.wit&gt;</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parsers">Parsing the IR</h2>
<div class="sectionbody">
<div class="paragraph">
<p>WizToolKit has a simple unified API for parsing both forms of the IR.
This page will start with number representations in the IR, then explain the options available for parsing, and finally a deeper dive into common paths for parsing.</p>
</div>
<div class="sect2">
<h3 id="numbers-in-the-ir">Numbers in the IR</h3>
<div class="paragraph">
<p>The SIEVE IR has two distint categories of numbers</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Wire indexes</dt>
<dd>
<p>These are represented with <code>wtk::index_t</code>, a typedef of <code>uint64_t</code>.</p>
</dd>
<dt class="hdlist1">Field element literals</dt>
<dd>
<p>These are numbers mod the relations <code>characteristic</code>, which may be arbitrarily large. For maximal flexibility, WizToolKit uses a <code>Number_T</code> template parameter, which should be integer-like (e.g. implement operators for <code>+</code>, <code>*</code>, <code>&lt;&lt;</code>, etc. Enough to implement string-to-int conversions).</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="parsing-options">Parsing Options</h3>
<div class="paragraph">
<p>WizToolKit has three parser implementations, however all implement a common interface through the <code>wtk::Parser&lt;Number_T&gt;</code> abstract class (<a href="api/wtk/Parser.html#api_Parser"><code>#include &lt;wtk/Parser.h&gt;</code></a>).
It is responsible for parsing the IR&#8217;s front matter, returning control for the user to decide how to parse the IR body, and then delegating the body to a helper, also with a common interface.</p>
</div>
<div class="paragraph">
<p>As an abstract class, <code>wtk::Parser&lt;Number_T&gt;</code> must be instantiated as one of its concrete implementations. WizToolKit offers three such implementations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wtk::antlr::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/antlr/Parser.html#api_antlr_Parser"><code>#include &lt;wtk/antlr/Parser.h&gt;</code></a>)</p>
</li>
<li>
<p><code>wtk::irregular::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/irregular/Parser.html#api_irregular_Parser"><code>#include &lt;wtk/irregular/Parser.h&gt;</code></a>)</p>
</li>
<li>
<p><code>wtk::flatbuffer::Parser&lt;Number_T&gt;</code> (from <a href="api/wtk/flatbuffer/Parser.html#api_flatbuffer_Parser"><code>#include &lt;wtk/flatbuffer/Parser.h&gt;</code></a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All have a constructor which takes a <code>std::string</code> naming the file to open.
Some have additional constructors.</p>
</div>
<div class="paragraph">
<p>Before going any further, it is worth thinking about the context for parsing the IR.
Is just a relation being parsed? Are all three of relation, instance, and short witness being parsed?
When parsing all three, we have found it easiest to expect them listed in a defined order and fail if they deviate rather than attempting to reorder them on the fly.
Later in this page we will show the expected order approach.</p>
</div>
<div class="paragraph">
<p>Here is the creation of an IRRegular parser with <code>unsigned long</code> as its <code>Number_T</code> (field-literal type).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-w"> </span><span class="tok-n">relation_name</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>

<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">irregular</span><span class="tok-o">::</span><span class="tok-n">Parser</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">(</span><span class="tok-n">relation_name</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the parser is created, the front matter is easy to parse.
<a href="api/wtk/Parser.html#Parser_parseHdrResParams"><code>parser.parseHdrResParams()</code></a> returns <code>true</code> on success, and sets public attributes of the <code>parser</code> for front matter attributes.
To check that it is a relation, the parser has a <code>resource</code> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">parseHdrResParams</span><span class="tok-p">()</span>
<span class="tok-w">    </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">resource</span><span class="tok-w"> </span><span class="tok-o">!=</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Resource</span><span class="tok-o">::</span><span class="tok-n">relation</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-cm">/* handle errors */</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a summary of the front matter attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="api/wtk/Parser.html#Parser_version"><code>parser.version</code></a> is the IR version number. Its a triplet of <code>major</code>, <code>minor</code>, and <code>patch</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
WizToolKit makes little attempt to handle older IR releases.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="api/wtk/Parser.html#Parser_characteristic"><code>parser.characteristic</code></a> (<code>Number_T</code>) and <a href="api/wtk/Parser.html#Parser_degree"><code>parser.degree</code></a> (<code>size_t</code>) form the field.</p>
</li>
<li>
<p><a href="api/wtk/Parser.html#Parser_resource"><code>parser.resource</code></a> is the resource type. <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource</code></a> is an enum with the following values</p>
<div class="ulist">
<ul>
<li>
<p><code>wtk::Resource::relation</code></p>
</li>
<li>
<p><code>wtk::Resource::instance</code></p>
</li>
<li>
<p><code>wtk::Resource::shortWitness</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="api/wtk/Parser.html#Parser_gateSet"><code>parser.gateSet</code></a> and <a href="api/wtk/Parser.html#Parser_featureToggles"><code>parser.featureToggles</code></a> are structs with indicators for which gates and which IR features are used by this relation. See <a href="api/wtk/IRParameters.html#struct_GateSet"><code>struct GateSet</code></a> and <a href="api/wtk/IRParameters.html#struct_FeatureToggles"><code>struct FeatureToggles</code></a></p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
The <a href="api/wtk/Parser.html#Parser_gateSet"><code>parser.gateSet</code></a> and <a href="api/wtk/Parser.html#Parser_featureToggles"><code>parser.featureToggles</code></a> attributes are assigned only for the relation, not for the instance or short witness.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now the user may check the front matter for acceptability.
For example, that the characteristic is prime, or from a specific family of primes.
The user may also want to error here if the <em>Gate Set</em> or a <em>Feature Toggle</em> is unsupported.</p>
</div>
<div class="paragraph">
<p>Next, the user must choose how to parse the body, the instance, and the short witness.
The headers of the instance and short witness can be parsed similarly to the relation&#8217;s.
However, the instance and short_witness do not have <em>Gate Set</em> or <em>Feature Toggles</em>, and must defer to the <em>relation</em>.</p>
</div>
<div class="paragraph">
<p>A critical decision is whether the <em>Gate Set</em> is <a href="api/wtk/Parser.html#struct_BooleanParser"><em>Boolean</em></a> or <a href="api/wtk/Parser.html#struct_ArithmeticParser"><em>arithmetic</em></a>.
This is because the parsing API splits on these boundaries.
Another potential decision is whether or not the relation is IR-<em>Simple</em>.
WizToolKit&#8217;s parsers have a streaming API for IR-Simple, which may improve performance for some relations.
However, the streaming API cannot handle non-simple relations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-w"> </span><span class="tok-n">instance_name</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-w"> </span><span class="tok-n">short_witness_name</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">irregular</span><span class="tok-o">::</span><span class="tok-n">Parser</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">instance_parser</span><span class="tok-p">(</span><span class="tok-n">instance_name</span><span class="tok-p">);</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">irregular</span><span class="tok-o">::</span><span class="tok-n">Parser</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">short_witness_parser</span><span class="tok-p">(</span><span class="tok-n">short_witness_name</span><span class="tok-p">);</span>

<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">instance_parser</span><span class="tok-p">.</span><span class="tok-n">parseHdrResParams</span><span class="tok-p">()</span>
<span class="tok-w">    </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-o">!</span><span class="tok-n">short_witness_parser</span><span class="tok-p">.</span><span class="tok-n">parseHdrResParams</span><span class="tok-p">()</span>
<span class="tok-w">    </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">characteristic</span><span class="tok-w"> </span><span class="tok-o">!=</span><span class="tok-w"> </span><span class="tok-n">instance_parser</span><span class="tok-p">.</span><span class="tok-n">characteristic</span>
<span class="tok-w">    </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">characteristic</span><span class="tok-w"> </span><span class="tok-o">!=</span><span class="tok-w"> </span><span class="tok-n">short_witness_parser</span><span class="tok-p">.</span><span class="tok-n">characteristic</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-cm">/* handle error */</span>
<span class="tok-p">}</span>

<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">resource</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Resource</span><span class="tok-o">::</span><span class="tok-n">relation</span><span class="tok-p">)</span>
<span class="tok-w">  </span><span class="tok-o">&amp;&amp;</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">gateSet</span><span class="tok-p">.</span><span class="tok-n">gateSet</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">GateSet</span><span class="tok-o">::</span><span class="tok-n">arithmetic</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-c1">// Parse arithmetic relation</span>
<span class="tok-w">  </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">AritmeticParser</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">arith_parser</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">arithmetic</span><span class="tok-p">();</span>

<span class="tok-w">  </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">featureToggles</span><span class="tok-p">.</span><span class="tok-n">simple</span><span class="tok-p">())</span><span class="tok-w"> </span><span class="tok-c1">// select the streaming API</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-c1">// See <a href="#Streaming-API">Streaming API</a></span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-w">  </span><span class="tok-k">else</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-c1">// See <a href="#Syntax-Tree-API">Syntax Tree API</a></span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-p">}</span>
<span class="tok-k">else</span><span class="tok-w"> </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">resource</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Resource</span><span class="tok-o">::</span><span class="tok-n">relation</span><span class="tok-p">)</span>
<span class="tok-w">  </span><span class="tok-o">&amp;&amp;</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">gateSet</span><span class="tok-p">.</span><span class="tok-n">gateSet</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">GateSet</span><span class="tok-o">::</span><span class="tok-n">boolean</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-c1">// Parse boolean relation, Note that the template is dropped,</span>
<span class="tok-w">  </span><span class="tok-c1">// because Boolean literals are always given as uint8_t.</span>
<span class="tok-w">  </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">BooleanParser</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">bool_parser</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">arithmetic</span><span class="tok-p">();</span>
<span class="tok-w">  </span><span class="tok-cm">/* Omitted... */</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="parsing-the-instance-and-short-witness">Parsing the Instance and Short Witness</h3>
<div class="paragraph">
<p>Both the instance and short-witness are abstracted as streams in the SIEVE IR.
WizToolKit handles these streams through the <a href="api/wtk/Parser.html#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;</code></a> API.</p>
</div>
<div class="paragraph">
<p>The <code>wtk::InputStream&lt;Number_T&gt;</code> objects are obtained through the parser after specializing to <a href="api/wtk/Parser.html#ArithmeticParser_instance">arithmetic</a> or <a href="api/wtk/Parser.html#BooleanParser_shortWitness">boolean</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-c1">// Get an arithmetic parser for an instance</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ArithmeticParser</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">a_ins_parser</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">instance_parser</span><span class="tok-p">.</span><span class="tok-n">arithmetic</span><span class="tok-p">();</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">a_ins</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">a_ins_parser</span><span class="tok-o">-&gt;</span><span class="tok-n">instance</span><span class="tok-p">();</span>

<span class="tok-c1">// Similarly, for Boolean short witness (as an example; instance and short</span>
<span class="tok-c1">// witness should have the same type).</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">BooleanParser</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">b_wit_parser</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">short_witness_parser</span><span class="tok-p">.</span><span class="tok-n">arithmetic</span><span class="tok-p">();</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">b_wit</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">b_wit_parser</span><span class="tok-o">-&gt;</span><span class="tok-n">shortWitness</span><span class="tok-p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a stream is obtained, its <a href="api/wtk/Parser.html#InputStream_next"><code>next(&#8230;&#8203;)</code></a> method may be called repeatedly for each element of the stream.
The return type of <code>next(&#8230;&#8203;)</code> will indicate if it succeeded, failed, or reached the end of the stream. It has a return-by-pointer argument for the stream element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-w"> </span><span class="tok-n">ins_val</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">StreamStatus</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">a_ins</span><span class="tok-o">-&gt;</span><span class="tok-n">next</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">ins_val</span><span class="tok-p">);</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">status</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">StreamStatus</span><span class="tok-o">::</span><span class="tok-n">end</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-cm">/* End of stream */</span><span class="tok-w"> </span><span class="tok-p">}</span>
<span class="tok-k">else</span><span class="tok-w"> </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">status</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">StreamStatus</span><span class="tok-o">::</span><span class="tok-n">error</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-cm">/* mid-stream parser error */</span><span class="tok-w"> </span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of the parsers (namely <a href="api/wtk/antlr/Parser.html#api_antlr_Parser">ANTLR</a> and <a href="api/wtk/antlr/Parser.html#api_flatbuffer_Parser">FlatBuffer</a>) will parse the entire stream up front, in which case a parser error is indicated on the first element, regardless of its place in the stream.
Other parsers (namely <a href="api/wtk/irregular/Parser.html#api_irregular_Parser">IRRegular</a>) work in a more true stream-wise fashion, reporting the error as it occurs.</p>
</div>
</div>
<div class="sect2">
<h3 id="Streaming-API">Streaming API for Relations</h3>
<div class="paragraph">
<p>The Streaming API, IR-<em>Simple</em> relations are parsed one gate at a time and reported immediately.
This only works for IR-<em>Simple</em> because these relations have no nested scopes or repetition.</p>
</div>
<div class="paragraph">
<p>To report gates, the user must implement the <a href="api/wtk/ArithmeticStreamHandler.html#api_ArithmeticStreamHandler"><code>wtk::ArithmeticStreamHandler&lt;Number_T&gt;</code></a> or <a href="api/wtk/BooleanStreamHandler.html#api_BooleanStreamHandler"><code>wtk::BooleanStreamHandler</code></a> abstract class (depending on <em>Gate Set</em>, obviously).
A brief example for Arithmetic is shown here.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">class</span><span class="tok-w"> </span><span class="tok-nc">UserArithmeticStreamHandler</span><span class="tok-w"> </span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-k">public</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ArithmeticStreamHandler</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAdd</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-c1">// output wire-number</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left_in</span><span class="tok-p">,</span><span class="tok-w">        </span><span class="tok-c1">// left input wire-number</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right_in</span><span class="tok-p">)</span><span class="tok-w">       </span><span class="tok-c1">// right input wire-number</span>
<span class="tok-w">    </span><span class="tok-k">override</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* omitted */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleMul</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-c1">// output wire-number</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left_in</span><span class="tok-p">,</span><span class="tok-w">        </span><span class="tok-c1">// left input wire-number</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right_in</span><span class="tok-p">)</span><span class="tok-w">       </span><span class="tok-c1">// right input wire-number</span>
<span class="tok-w">    </span><span class="tok-k">override</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* omitted */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-cm">/* Remaining methods omitted... */</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Invocation for the streaming API is through the <a href="api/wtk/Parser.html#ArithmeticParser_parseStream"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code> method <code>parseStream(&#8230;&#8203;)</code></a> or <a href="api/wtk/Parser.html#BooleanParser_parseStream"><code>wtk::BooleanParser</code> method <code>parseStream(&#8230;&#8203;)</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-c1">// For an arithmetic simple relation</span>
<span class="tok-n">UserArithmeticStreamHandler</span><span class="tok-w"> </span><span class="tok-n">handler</span><span class="tok-p">;</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">arith_parser</span><span class="tok-o">-&gt;</span><span class="tok-n">parseStream</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">handler</span><span class="tok-p">))</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-cm">/* Parse Error */</span><span class="tok-w"> </span><span class="tok-p">}</span>

<span class="tok-c1">// For a Boolean simple relation</span>
<span class="tok-n">UserBooleanStreamHandler</span><span class="tok-w"> </span><span class="tok-n">handler</span><span class="tok-p">;</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">bool_parser</span><span class="tok-o">-&gt;</span><span class="tok-n">parseStream</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">handler</span><span class="tok-p">))</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-cm">/* Parse Error */</span><span class="tok-w"> </span><span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Syntax-Tree-API">Syntax Tree API for Relations</h3>
<div class="paragraph">
<p>The Syntax Tree API can handle any relation, regardless of its feature set.
However, it must parse the entire relation ahead of time, and allocate a syntax tree, which for very long relations can consume a lot of memory.</p>
</div>
<div class="paragraph">
<p>The syntax tree is defined by <a href="api/wtk/IRTree.html#api_IRTree">#include &lt;wtk/IRTree.h&gt;</a>.
At a top-level it is defined by the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a>, which aggregates function definitions and the relation&#8217;s main body.
Each scope is a <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;</code></a> with the ability to retrieve gates such as <a href="api/wtk/IRTree.html#struct_BinaryGate"><code>wtk::BinaryGate</code></a> (binary referring to its cardinality) or <a href="api/wtk/IRTree.html#struct_Input"><code>wtk::Input</code></a> (for the instance or short-witness).</p>
</div>
<div class="paragraph">
<p>The Tree is again retrieved through the <a href="api/wtk/Parser.html#ArithmeticParser_parseTree"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code></a> or <a href="api/wtk/Parser.html#BooleanParser_parseTree"><code>wtk::BooleanParser</code></a> <code>parseTree()</code> method (only Arithmetic shown).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">ir_tree</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">arith_parser</span><span class="tok-o">-&gt;</span><span class="tok-n">parseTree</span><span class="tok-p">();</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">ir_tree</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-k">nullptr</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-cm">/* Parser error */</span><span class="tok-w"> </span><span class="tok-p">}</span>

<span class="tok-c1">// To be implemented by the user.</span>
<span class="tok-n">process_ir_tree</span><span class="tok-p">(</span><span class="tok-n">ir_tree</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To process the relation, the user must do a tree traversal.
At a top level, the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> holds a list of function declarations (we&#8217;ll get to these later), and the relation&#8217;s main body.
The main body is just a <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;</code></a>, which is an indirectly-recursive type, defining much of the syntax tree.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">process_ir_tree</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">tree</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-c1">// See <a href="#Syntax-Tree-Functions">Syntax Tree API for Functions</a> for function-declarations.</span>

<span class="tok-w">  </span><span class="tok-c1">// The circuit&#39;s entry point is its body.</span>
<span class="tok-w">  </span><span class="tok-n">process_directive_list</span><span class="tok-p">(</span><span class="tok-n">tree</span><span class="tok-o">-&gt;</span><span class="tok-n">body</span><span class="tok-p">());</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Processing the <a href="api/wtk/IRTree.html#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number-T&gt;</code></a> is a simple matter of traversing each directive in the scope, and switching on its <a href="api/wtk/IRTree.html#DirectiveList_enum_Type">type</a>.
Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">process_directive_list</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">dir_list</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-c1">// The DirectiveList is a tree type, leaf-nodes are typically gates</span>
<span class="tok-w">  </span><span class="tok-c1">// (@and/@xor/@mul/etc.) with other nodes taking the form of higher</span>
<span class="tok-w">  </span><span class="tok-c1">// level features.</span>

<span class="tok-w">  </span><span class="tok-k">for</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">&lt;</span><span class="tok-w"> </span><span class="tok-n">dir_list</span><span class="tok-o">-&gt;</span><span class="tok-n">size</span><span class="tok-p">();</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-k">switch</span><span class="tok-p">(</span><span class="tok-n">dir_list</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">(</span><span class="tok-n">i</span><span class="tok-p">))</span>
<span class="tok-w">    </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-k">case</span><span class="tok-w"> </span><span class="tok-no">wtk</span><span class="tok-o">::</span><span class="tok-no">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-no">unsigned</span><span class="tok-w"> </span><span class="tok-no">long</span><span class="tok-o">&gt;::</span><span class="tok-no">BINARY_GATE</span><span class="tok-p">:</span>
<span class="tok-w">    </span><span class="tok-p">{</span>
<span class="tok-w">      </span><span class="tok-c1">// the &quot;binary&quot; (in signature, not value) gate describes</span>
<span class="tok-w">      </span><span class="tok-c1">// @and/@xor/@mul/@add gates.</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">BinaryGate</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">gate</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">dir_list</span><span class="tok-o">-&gt;</span><span class="tok-n">binaryGate</span><span class="tok-p">(</span><span class="tok-n">i</span><span class="tok-p">);</span>
<span class="tok-w">      </span><span class="tok-c1">// these are the input and output wire numbers of the gate</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-n">left_input_wire</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">gate</span><span class="tok-o">-&gt;</span><span class="tok-n">leftWire</span><span class="tok-p">();</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-n">right_input_wire</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">gate</span><span class="tok-o">-&gt;</span><span class="tok-n">rightWire</span><span class="tok-p">();</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-n">output_wire</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">gate</span><span class="tok-o">-&gt;</span><span class="tok-n">outputWire</span><span class="tok-p">();</span>

<span class="tok-w">      </span><span class="tok-c1">// The gate&#39;s calculation is an enum</span>
<span class="tok-w">      </span><span class="tok-k">switch</span><span class="tok-p">(</span><span class="tok-n">gate</span><span class="tok-o">-&gt;</span><span class="tok-n">calculation</span><span class="tok-p">())</span>
<span class="tok-w">      </span><span class="tok-p">{</span>
<span class="tok-w">      </span><span class="tok-k">case</span><span class="tok-w"> </span><span class="tok-no">wtk</span><span class="tok-o">::</span><span class="tok-no">BinaryGate</span><span class="tok-o">::</span><span class="tok-no">AND</span><span class="tok-p">:</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">break</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-p">}</span>
<span class="tok-w">      </span><span class="tok-k">case</span><span class="tok-w"> </span><span class="tok-no">wtk</span><span class="tok-o">::</span><span class="tok-no">BinaryGate</span><span class="tok-o">::</span><span class="tok-no">XOR</span><span class="tok-p">:</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">break</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-p">}</span>
<span class="tok-w">      </span><span class="tok-k">case</span><span class="tok-w"> </span><span class="tok-no">wtk</span><span class="tok-o">::</span><span class="tok-no">BinaryGate</span><span class="tok-o">::</span><span class="tok-no">ADD</span><span class="tok-p">:</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">break</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-p">}</span>
<span class="tok-w">      </span><span class="tok-k">case</span><span class="tok-w"> </span><span class="tok-no">wtk</span><span class="tok-o">::</span><span class="tok-no">BinaryGate</span><span class="tok-o">::</span><span class="tok-no">MUL</span><span class="tok-p">:</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">break</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-p">}</span>
<span class="tok-w">      </span><span class="tok-p">}</span>

<span class="tok-w">      </span><span class="tok-k">break</span><span class="tok-p">;</span>
<span class="tok-w">    </span><span class="tok-p">}</span>
<span class="tok-w">    </span><span class="tok-cm">/* other gate-types omitted for brevity */</span>
<span class="tok-w">    </span><span class="tok-k">case</span><span class="tok-w"> </span><span class="tok-no">wtk</span><span class="tok-o">::</span><span class="tok-no">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-no">unsigned</span><span class="tok-w"> </span><span class="tok-no">long</span><span class="tok-o">&gt;::</span><span class="tok-no">ANON_FUNCTION</span><span class="tok-p">:</span>
<span class="tok-w">    </span><span class="tok-p">{</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">AnonFunction</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">anon_func</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">dir_list</span><span class="tok-o">-&gt;</span><span class="tok-n">anonFunction</span><span class="tok-p">(</span><span class="tok-n">i</span><span class="tok-p">);</span>
<span class="tok-w">      </span><span class="tok-c1">// The signature of the function, along with its inputs/outputs</span>
<span class="tok-w">      </span><span class="tok-c1">// is easily retrievable.</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">output_wires</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">anon_func</span><span class="tok-o">-&gt;</span><span class="tok-n">outputList</span><span class="tok-p">();</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">input_wires</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">anon_func</span><span class="tok-o">-&gt;</span><span class="tok-n">inputList</span><span class="tok-p">();</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-n">num_instance_vals</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">anon_func</span><span class="tok-o">-&gt;</span><span class="tok-n">instanceCount</span><span class="tok-p">();</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-n">num_witness_vals</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">anon_func</span><span class="tok-o">-&gt;</span><span class="tok-n">shortWitnessCount</span><span class="tok-p">();</span>

<span class="tok-w">      </span><span class="tok-c1">// To process the body of the anonymous function, use recursion.</span>
<span class="tok-w">      </span><span class="tok-n">process_directive_list</span><span class="tok-p">(</span><span class="tok-n">anon_func</span><span class="tok-o">-&gt;</span><span class="tok-n">body</span><span class="tok-p">());</span>
<span class="tok-w">      </span><span class="tok-k">break</span><span class="tok-p">;</span>
<span class="tok-w">    </span><span class="tok-p">}</span>
<span class="tok-w">    </span><span class="tok-cm">/* Other feature-types omitted for brevity */</span>
<span class="tok-w">    </span><span class="tok-p">}</span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="Syntax-Tree-Functions">Syntax Tree API for Functions</h4>
<div class="paragraph">
<p>For IR named-functions, the body of a function and its invocation are split.
All function-declarations are listed at the top of a relation.
Correspondingly, the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> has a <a href="api/wtk/IRTree.html#IRTree_functionDeclare"><code>functionDeclare(i)</code></a> method for retrieval, and <a href="api/wtk/IRTree.html#IRTree_size"><code>size()</code></a> indicating how many may be retrieved.</p>
</div>
<div class="paragraph">
<p>For easy access, we suggest entering the function declarations into a <code>std::map</code> or <code>std::unordered_map</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-c1">// declare a map to hold them</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">map</span><span class="tok-o">&lt;</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">FunctionDeclare</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*&gt;</span><span class="tok-w"> </span><span class="tok-n">functions_map</span><span class="tok-p">;</span>

<span class="tok-w">  </span><span class="tok-c1">// enter each function-declaration into the map</span>
<span class="tok-w">  </span><span class="tok-k">for</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-w"> </span><span class="tok-o">&lt;</span><span class="tok-w"> </span><span class="tok-n">tree</span><span class="tok-o">-&gt;</span><span class="tok-n">size</span><span class="tok-p">();</span><span class="tok-w"> </span><span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">FunctionDeclare</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">function</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">tree</span><span class="tok-o">-&gt;</span><span class="tok-n">functionDeclare</span><span class="tok-p">(</span><span class="tok-n">i</span><span class="tok-p">);</span>

<span class="tok-w">    </span><span class="tok-c1">// function-&gt;name() is a char* while std::map works only with std::strings</span>
<span class="tok-w">    </span><span class="tok-c1">// with c++17, it should be okay to use std::string_view so long as</span>
<span class="tok-w">    </span><span class="tok-c1">// *tree outlives functions_map</span>
<span class="tok-w">    </span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-w"> </span><span class="tok-nf">name</span><span class="tok-p">(</span><span class="tok-n">function</span><span class="tok-o">-&gt;</span><span class="tok-n">name</span><span class="tok-p">());</span>

<span class="tok-w">    </span><span class="tok-c1">// check that the function wasn&#39;t previously declared</span>
<span class="tok-w">    </span><span class="tok-k">auto</span><span class="tok-w"> </span><span class="tok-n">finder</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">functions_map</span><span class="tok-p">.</span><span class="tok-n">find</span><span class="tok-p">(</span><span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-w">    </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">finder</span><span class="tok-w"> </span><span class="tok-o">!=</span><span class="tok-w"> </span><span class="tok-n">functions_map</span><span class="tok-p">.</span><span class="tok-n">end</span><span class="tok-p">())</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-cm">/* Error */</span><span class="tok-w"> </span><span class="tok-p">}</span>

<span class="tok-w">    </span><span class="tok-n">functions_map</span><span class="tok-p">[</span><span class="tok-n">name</span><span class="tok-p">]</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">function</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a function is invoked (with a <a href="api/wtk/IRTree.html#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a> directive), its is now just a matter of looking up its name in the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-w">    </span><span class="tok-k">case</span><span class="tok-w"> </span><span class="tok-no">wtk</span><span class="tok-o">::</span><span class="tok-no">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-no">unsigned</span><span class="tok-w"> </span><span class="tok-no">long</span><span class="tok-o">&gt;::</span><span class="tok-no">FUNCTION_INVOKE</span><span class="tok-p">:</span>
<span class="tok-w">    </span><span class="tok-p">{</span>
<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">FunctionInvoke</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">invoke</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">dir_list</span><span class="tok-o">-&gt;</span><span class="tok-n">functionInvoke</span><span class="tok-p">(</span><span class="tok-n">i</span><span class="tok-p">);</span>

<span class="tok-w">      </span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-w"> </span><span class="tok-nf">name</span><span class="tok-p">(</span><span class="tok-n">invoke</span><span class="tok-o">-&gt;</span><span class="tok-n">name</span><span class="tok-p">());</span>
<span class="tok-w">      </span><span class="tok-k">auto</span><span class="tok-w"> </span><span class="tok-n">finder</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">functions_map</span><span class="tok-p">.</span><span class="tok-n">find</span><span class="tok-p">(</span><span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-w">      </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">finder</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">functions_map</span><span class="tok-p">.</span><span class="tok-n">end</span><span class="tok-p">())</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-cm">/* Error */</span><span class="tok-w"> </span><span class="tok-p">}</span>

<span class="tok-w">      </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">FunctionDeclare</span><span class="tok-o">&lt;</span><span class="tok-kt">unsigned</span><span class="tok-w"> </span><span class="tok-kt">long</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">declaration</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">finder</span><span class="tok-o">-&gt;</span><span class="tok-n">second</span><span class="tok-p">;</span>

<span class="tok-w">      </span><span class="tok-c1">// To process the body of the function, use recursion.</span>
<span class="tok-w">      </span><span class="tok-n">process_directive_list</span><span class="tok-p">(</span><span class="tok-n">declaration</span><span class="tok-o">-&gt;</span><span class="tok-n">body</span><span class="tok-p">());</span>
<span class="tok-w">      </span><span class="tok-k">break</span><span class="tok-p">;</span>
<span class="tok-w">    </span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information about the IR Syntax Tree, See <a href="api/wtk/IRTree.html#api_IRTree"><code>#include &lt;wtk/IRTree.h&gt;</code></a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="backends">WizToolKit for Backends</h2>
<div class="sectionbody">
<div class="paragraph">
<p>WizToolKit&#8217;s BOLT and PLASMASnooze IR interpreters share a common Backend API.
The advantage of this is it allows the backend to focus on proofs and reuse IR semantics from WizToolKit.
BOLT is a "two-pass" interpreter and is most ideally suited for relations which rely heavily on loops.
PLASMASnooze is a "single-pass" interpreter and picks up the slack when very few gates are reused.</p>
</div>
<div class="paragraph">
<p>The following includes are required.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="api/wtk/bolt/Builder.html#api_bolt_Builder"><code>#include &lt;wtk/bolt/Builder.h&gt;</code></a></dt>
<dd>
<p>the <em>build</em> phase of the BOLT interpreter.</p>
</dd>
<dt class="hdlist1"><a href="api/wtk/bolt/Evaluator.html#api_bolt_Evaluator"><code>#include &lt;wtk/bolt/Evaluator.h&gt;</code></a></dt>
<dd>
<p>the <em>evaluate</em> phase of BOLT interpreter.</p>
</dd>
<dt class="hdlist1"><a href="api/wtk/bolt/PLASMASnooze.html#api_bolt_PLASMASnooze"><code>#include &lt;wtk/bolt/PLASMASnooze.h&gt;</code></a></dt>
<dd>
<p>the PLASMASnooze interpreter.</p>
</dd>
<dt class="hdlist1"><a href="api/wtk/bolt/ArithmeticPLASMASnoozeHandler.html#api_bolt_ArithmeticPLASMASnoozeHandler"><code>#include &lt;wtk/bolt/ArithmeticPLASMASnoozeHandler.h&gt;</code></a>, and <a href="api/wtk/bolt/BooleanPLASMASnoozeHandler.html#api_bolt_BooleanPLASMASnoozeHandler"><code>#include &lt;wtk/bolt/BooleanPLASMASnoozeHandler.h&gt;</code></a></dt>
<dd>
<p>the PLASMASnooze interpreter, adapted to the <a href="parsers.html#Streaming-API">Streaming Parser API</a>.</p>
</dd>
<dt class="hdlist1"><a href="api/wtk/bolt/Backend.html#api_bolt_Backend"><code>#include &lt;wtk/bolt/Backend.h&gt;</code></a></dt>
<dd>
<p>the interface which a backend implementor must implement.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For those who are curious about the naming scheme of these, BOLT is short for <strong>B</strong>etter <strong>O</strong>ptimization via <strong>L</strong>ookup-reuse and <strong>T</strong>wo-pass.
PLASMASnooze is an improvement over <a href="tools/wtk-firealarm.html#tools_firealarm">FIREALARM</a> in the sense of performance and of plugability with ZK Backends.
However, it is also a disprovement in the sense that it relaxes certain IR semantics, for example, it allows reassignment to a wire, after the wire was <code>@delete</code>d.
Thus PLASMA is an improvement upon FIRE, and Snooze is the opposite of ALARM.
PLASMASnooze stands for <strong>P</strong>ractical <strong>L</strong>ocal <strong>A</strong>cceleration for <strong>S</strong>ingle-pass with <strong>M</strong>alleable <strong>A</strong>ssumtions <strong>Snooze</strong>.</p>
</div>
<div class="sect2">
<h3 id="numeric-representations">Numeric Representations</h3>
<div class="paragraph">
<p>In this API there are generally three numeric representation types.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Wire numbers</dt>
<dd>
<p>A <code>typedef</code> named <code>wtk::index_t</code> defines the 64-bit unsigned integers (with wraparound) required by the IR specification for indices in the wire numbering system.
These are almost entirely hidden from the backend.</p>
</dd>
<dt class="hdlist1">Wire values</dt>
<dd>
<p>A template parameter which is typically referred to as <code>Wire_T</code> must be specified by the backend to carry the value across each wire.</p>
</dd>
<dt class="hdlist1">Parser literals</dt>
<dd>
<p>A template parameter which is typically referred to as <code>Number_T</code> must be the same numeric type as parameterizing the parser.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="the-backend-api">The Backend API</h3>
<div class="paragraph">
<p>The <a href="api/wtk/bolt/Backend.html#class_Backend"><code>wtk::bolt::Backend&lt;Wire_T, Number_T&gt;</code></a> is a simple abstract class which must be implemented by the backend.
It declares a number of methods which must be overridden by the backend.
Each method handles a simple gate, such as <code>@mul</code> or <code>@xor</code>.
WizToolKit guarantees that it will only call methods of one <em>Gate Set</em>.
If an implementor can only handle one <em>Gate Set</em> it is acceptable to have empty or failing implementations for the other <em>Gate Set</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">typedef</span><span class="tok-w"> </span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-cm">/* something that is default-constructible */</span><span class="tok-p">;</span>

<span class="tok-k">struct</span><span class="tok-w"> </span><span class="tok-nc">MyBackend</span><span class="tok-w"> </span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-k">public</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Backend</span><span class="tok-o">&lt;</span><span class="tok-n">MyWire</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">addGate</span><span class="tok-p">(</span><span class="tok-n">MyWire</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-k">override</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* implementation */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">mulGate</span><span class="tok-p">(</span><span class="tok-n">MyWire</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-k">override</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* implementation */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-cm">/* remaining methods omitted for brevity */</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="assert-zero">Assert Zero</h4>
<div class="paragraph">
<p>The <code>@assert_zero</code> directive indicates that the proof would fail if its input were non-zero.
The Backend API expects the implementor to cache assertions and check them at the end.
This is done with a pair of <a href="api/wtk/bolt/Backend.html#Backend_assertZero"><code>assertZero(&#8230;&#8203;)</code></a> and <a href="api/wtk/bolt/Backend.html#Backend_check"><code>check()</code></a> methods.
Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-w">  </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-n">failureCache</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-nb">false</span><span class="tok-p">;</span>

<span class="tok-w">  </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">assertZero</span><span class="tok-p">(</span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">wire</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-k">override</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">failureCache</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-p">(</span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-o">!=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">failureCache</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">check</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-k">override</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-k">return</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">failureCache</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The top-level caller may call <a href="api/wtk/bolt/Backend.html#Backend_check"><code>check()</code></a> at the top-level to check for failures.
If shutdown code is necessary, it may be written in either the the <a href="api/wtk/bolt/Backend.html#Backend_finish"><code>finish()</code></a> method or the destructor.
The top-level caller must call <code>finish()</code> at the top level scope.</p>
</div>
</div>
<div class="sect3">
<h4 id="replacing-exponentiation-in-switch-statements">Replacing Exponentiation in Switch-Statements</h4>
<div class="paragraph">
<p>By default, WizToolKit uses exponentiation (and <a href="https://en.wikipedia.org/wiki/Fermat's_little_theorem">Fermat&#8217;s Little Theorem</a>) to test which case is selected in an arithmetic switch-statement.
This means that there are <code>n log(P)</code> many additional multiplications per switch statement (<code>n</code> being number of cases and <code>P</code> being the prime).
If an implementor&#8217;s ZK system can improve upon this, they may override the <code>caseSelect(&#8230;&#8203;)</code> function.
The <code>selected_bit</code> output wire must be assigned <code>1</code> or <code>0</code> when the <code>select_wire</code> input wire is or is not equal to the <code>case_number</code> field-literal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-w">  </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">caseSelect</span><span class="tok-p">(</span><span class="tok-n">MyWire</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">selected_bit</span><span class="tok-p">,</span>
<span class="tok-w">      </span><span class="tok-kt">uint64_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">case_number</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">MyWire</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">select_wire</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-k">override</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-c1">// Implement this</span>
<span class="tok-w">  </span><span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="invoking-bolt">Invoking BOLT</h3>
<div class="paragraph">
<p>BOLT has two phases of invocation.
First <a href="api/wtk/bolt/Builder.html#api_bolt_Builder"><em>build</em></a> translates the IR syntax tree to a more accelerated form, then <a href="api/wtk/bolt/Builder.html#api_bolt_Evaluator"><em>evaluate</em></a> processes the relation, invoking methods of the backend as necessary.
Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-c1">// Collect these from the parser</span>
<span class="tok-kt">uint64_t</span><span class="tok-w"> </span><span class="tok-n">characteristic</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-n">is_boolean</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">relation</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>

<span class="tok-c1">// Build the relation. *bolt_relation has the same lifetime as builder</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Builder</span><span class="tok-o">&lt;</span><span class="tok-n">MyWire</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">builder</span><span class="tok-p">(</span><span class="tok-n">characteristic</span><span class="tok-p">);</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Bolt</span><span class="tok-o">&lt;</span><span class="tok-n">MyWire</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">bolt_relation</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">builder</span><span class="tok-p">.</span><span class="tok-n">build</span><span class="tok-p">(</span><span class="tok-n">relation</span><span class="tok-p">);</span>

<span class="tok-c1">// Check that build succeeded and then evaluate.</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">bolt_relation</span><span class="tok-w"> </span><span class="tok-o">!=</span><span class="tok-w"> </span><span class="tok-k">nullptr</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-c1">// Evaluate the relation</span>
<span class="tok-w">  </span><span class="tok-n">MyBackend</span><span class="tok-w"> </span><span class="tok-nf">backend</span><span class="tok-p">(</span><span class="tok-n">characteristic</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">is_boolean</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">);</span>
<span class="tok-w">  </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Evaluator</span><span class="tok-o">&lt;</span><span class="tok-n">MyWire</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">evaluator</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">backend</span><span class="tok-p">);</span>

<span class="tok-w">  </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">evaluator</span><span class="tok-p">.</span><span class="tok-n">evaluate</span><span class="tok-p">(</span><span class="tok-n">bolt_relation</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-p">))</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* Instance or witness is poorly formed */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-w">  </span><span class="tok-k">else</span><span class="tok-w"> </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">backend</span><span class="tok-p">.</span><span class="tok-n">check</span><span class="tok-p">())</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* an assert zero failed, or other things happened to invalidate the proof */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-w">  </span><span class="tok-k">else</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* success */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>

<span class="tok-w">  </span><span class="tok-n">backend</span><span class="tok-p">.</span><span class="tok-n">finish</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>At invocation time, it may be nonsensical for the a verifier to have a witness stream.
To handle this, <a href="api/wtk/bolt/Evaluator.html#Evaluator_evaluate"><code>evaluate(&#8230;&#8203;)</code></a> may be called with a <code>nullptr</code>.
In this case, the evaluator will feed the backend zeroes in place of the witness.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-w">  </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">evaluator</span><span class="tok-p">.</span><span class="tok-n">evaluate</span><span class="tok-p">(</span><span class="tok-n">bolt_relation</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-k">nullptr</span><span class="tok-p">))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="invoking-plasmasnooze">Invoking PLASMASnooze</h3>
<div class="paragraph">
<p><a href="api/wtk/bolt/PLASMASnooze.html#api_bolt_PLASMASnooze">PLASMASnooze</a> has just a single phase of execution.
Instead of returning true/false for success or failure, it returns an <a href="api/wtk/bolt/PLASMASnooze.html#enum_PLASMASnoozeStatus">enumeration indicating which resource caused the failure</a>.
As with BOLT, PLASMASnooze indicates only failures of each individual resource, leaving the backend to indicate failure of the proof.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-c1">// Collect these from the parser</span>
<span class="tok-kt">uint64_t</span><span class="tok-w"> </span><span class="tok-n">characteristic</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-n">is_boolean</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">relation</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>

<span class="tok-c1">// Evaluate the relation</span>
<span class="tok-n">MyBackend</span><span class="tok-w"> </span><span class="tok-nf">backend</span><span class="tok-p">(</span><span class="tok-n">characteristic</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">is_boolean</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">);</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnooze</span><span class="tok-o">&lt;</span><span class="tok-n">MyWire</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">snooze</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">backend</span><span class="tok-p">);</span>

<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-w"> </span><span class="tok-o">=</span>
<span class="tok-w">  </span><span class="tok-n">snooze</span><span class="tok-p">.</span><span class="tok-n">evaluate</span><span class="tok-p">(</span><span class="tok-n">relation</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-p">);</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-o">::</span><span class="tok-n">bad_relation</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-cm">/* Relation is poorly formed */</span>
<span class="tok-p">}</span>
<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-o">::</span><span class="tok-n">bad_stream</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-cm">/* Instance or witness is poorly formed */</span>
<span class="tok-p">}</span>
<span class="tok-k">else</span><span class="tok-w"> </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">backend</span><span class="tok-p">.</span><span class="tok-n">check</span><span class="tok-p">())</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-cm">/* an assert zero failed, or other things happened to invalidate the proof */</span>
<span class="tok-p">}</span>
<span class="tok-k">else</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-cm">/* success */</span>
<span class="tok-p">}</span>

<span class="tok-n">backend</span><span class="tok-p">.</span><span class="tok-n">finish</span><span class="tok-p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly to BOLT, PLASMASnooze may be invoked with a null witness, to feed a verifier zeroes in the place of witnesses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-w"> </span><span class="tok-o">=</span>
<span class="tok-w">  </span><span class="tok-n">snooze</span><span class="tok-p">.</span><span class="tok-n">evaluate</span><span class="tok-p">(</span><span class="tok-n">relation</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-k">nullptr</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="streaming-plasmasnooze">Streaming PLASMASnooze</h4>
<div class="paragraph">
<p>A further optimization to PLASMASnooze, when processing strict IR-Simple, is to use the <a href="parsers.html#Streaming-API">parser&#8217;s streaming API</a>.
When the relation is IR-Simple (a completely "flat" list of gates), the parser can pass each gate to a handler immediately after its parsed, rather than adding it to a syntax tree.
The <a href="api/wtk/bolt/ArithmeticPLASMASnoozeHandler.html#api_bolt_ArithmeticPLASMASnoozeHandler"><code>wtk::bolt::ArithmeticPLASMASnoozeHandler&lt;Wire_T, Number_T&gt;</code></a> and <a href="api/wtk/bolt/BooleanPLASMASnoozeHandler.html#api_bolt_BooleanPLASMASnoozeHandler"><code>wtk::bolt::BooleanPLASMASnoozeHandler&lt;Wire_T&gt;</code> (<code>Number_T</code> is fixed as <code>uint8_t</code>)</a> implement the Streaming API for PLASMASnooze. the <code>check()</code> method of each must be used to collect the <a href="api/wtk/bolt/PLASMASnooze.html#enum_PLASMASnoozeStatus">status code (<code>wtk::bolt::PLASMASnoozeStatus</code>)</a>.</p>
</div>
<div class="paragraph">
<p>Here is an example invocation for arithmetic PLASMASnooze streaming.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-c1">// Collect these from the parser</span>
<span class="tok-kt">uint64_t</span><span class="tok-w"> </span><span class="tok-n">characteristic</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-n">is_boolean</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ArithemticParser</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">relation_parser</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">;</span>

<span class="tok-c1">// Evaluate the relation</span>
<span class="tok-n">MyBackend</span><span class="tok-w"> </span><span class="tok-nf">backend</span><span class="tok-p">(</span><span class="tok-n">characteristic</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">is_boolean</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-cm">/* ... */</span><span class="tok-p">);</span>
<span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">ArithmeticPLASMASnoozeHandler</span><span class="tok-o">&lt;</span><span class="tok-n">MyWire</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">snooze</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">backend</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-p">);</span>

<span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">relation_parser</span><span class="tok-o">-&gt;</span><span class="tok-n">parseStream</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">snooze</span><span class="tok-p">))</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-cm">/* Syntax error */</span>
<span class="tok-p">}</span>
<span class="tok-k">else</span>
<span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">snooze</span><span class="tok-p">.</span><span class="tok-n">check</span><span class="tok-p">();</span>
<span class="tok-w">  </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-o">::</span><span class="tok-n">bad_relation</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-p">)</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* Relation is poorly formed */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-w">  </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-o">::</span><span class="tok-n">bad_stream</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">status</span><span class="tok-p">)</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* Instance or witness is poorly formed */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-w">  </span><span class="tok-k">else</span><span class="tok-w"> </span><span class="tok-k">if</span><span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">backend</span><span class="tok-p">.</span><span class="tok-n">check</span><span class="tok-p">())</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* an assert zero failed, or other things happened to invalidate the proof */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-w">  </span><span class="tok-k">else</span>
<span class="tok-w">  </span><span class="tok-p">{</span>
<span class="tok-w">    </span><span class="tok-cm">/* success */</span>
<span class="tok-w">  </span><span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-n">backend</span><span class="tok-p">.</span><span class="tok-n">finish</span><span class="tok-p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For verifiers, who have access to the instance but not the witness, the handler may be constructed with a <code>nullptr</code> witness.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">ArithmeticPLASMASnoozeHandler</span><span class="tok-o">&lt;</span><span class="tok-n">MyWire</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-n">snooze</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">backend</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-k">nullptr</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix-a-api-documentation">Appendix A: API Documentation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="api_Parser">Parser API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/Parser.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Parser API is parameterized on a <code>Number_T</code> template.
<code>Number_T</code> should be integer-like enough to be parsed from a string.
This API is abstract and implemented by parsers for various IR formats.</p>
</div>
<div class="sect3">
<h4 id="struct_Parser"><code>template&lt;typename Number_T&gt; struct Parser</code></h4>
<div class="paragraph">
<p>The Parser will read the IR&#8217;s front matter before delegating to an <a href="#struct_ArithmeticParser"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code></a> or a <a href="#struct_BooleanParser"><code>wtk::BooleanParser</code></a>.</p>
</div>
<div class="paragraph">
<p>The struct&#8217;s public data members are set to default values (mostly 0) at construction and assigned concrete values as parse methods are invoked.
The parser methods are expected to be called in the correct order (<a href="#Parser_parseHeader"><code>parseHeader()</code></a>, <a href="#Parser_parseResource"><code>parseResource()</code></a>, and finally for relations only <a href="#Parser_parseParameters"><code>parseParameters()</code></a>).
A helper for calling them in the correct order is provided as <a href="#Parser_parseHdrResParams"><code>parseHdrResParams()</code></a>.</p>
</div>
<div class="paragraph">
<p>When the front-matter has been parsed, one of <a href="#Parser_arithmetic"><code>arithmetic()</code></a>, <a href="#Parser_arithmetic64"><code>arithmetic64()</code></a>,  <a href="#Parser_arithmetic32"><code>arithmetic32()</code></a>, or <a href="#Parser_boolean"><code>boolean()</code></a> may be invoked to delegate parsing the body to either of <a href="#struct_ArithmeticParser"><code>wtk::ArithemticParser&lt;&#8230;&#8203;&gt;</code></a>
or <a href="#struct_BooleanParser"><code>wtk::BooleanParser</code></a>.</p>
</div>
<div class="sect4">
<h5 id="Parser_parseHeader"><code>bool parseHeader()</code></h5>
<div class="paragraph">
<p>Parses the resources header section setting the following attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Parser_version"><code>struct { &#8230;&#8203; } version</code></a></p>
</li>
<li>
<p><a href="#Parser_characteristic"><code>Number_T characteristic</code></a></p>
</li>
<li>
<p><a href="#Parser_degree"><code>size_t degree</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Returns <code>true</code> on success, false if a parse error occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">parseHeader</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_parseResource"><code>bool parseResource()</code></h5>
<div class="paragraph">
<p>Parses the resource type and sets the <a href="#Parser_resource"><code>wtk::Resource resource</code></a> attribute.</p>
</div>
<div class="paragraph">
<p>Returns <code>true</code> on success, false if a parse error occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">parseResource</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_parseParameters"><code>bool parseParameters()</code></h5>
<div class="paragraph">
<p>Parses the relation&#8217;s parameters and sets the following attributes.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Parser_gateSet"><code>wtk::GateSet gateSet</code></a></p>
</li>
<li>
<p><a href="#Parser_featureToggles"><code>wtk::FeatureToggles featureToggles</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Returns <code>true</code> on success, false if a parse error occurs.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">WARNING</dt>
<dd>
<p><code>parseParameters()</code> should only be used if <code>resource == wtk::Resource::relation</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">parseParameters</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_parseHdrResParams"><code>bool parseHdrResParams()</code></h5>
<div class="paragraph">
<p>This is a helper to call <a href="#Parser_parseHeader"><code>parseHeader()</code></a>, <a href="#Parser_parseResource"><code>parseResource()</code></a>, and, if necessary, <a href="#Parser_parseParameters"><code>parseParameters()</code></a> in sequence.</p>
</div>
<div class="paragraph">
<p>Returns <code>true</code> on success, false if a parse error occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">parseHdrResParams</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_version"><code>struct { &#8230;&#8203; } version</code></h5>
<div class="paragraph">
<p>The version is the first line of an IR resource.
Although WizToolKit tends to be tied to a particular IR version, the Parser does not make any checks for the particular IR version.</p>
</div>
<div class="paragraph">
<p>The version consists of <code>major</code>, <code>minor</code>, and <code>patch</code> elements, all of type <code>size_t</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">struct</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">major</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">minor</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-w">  </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">patch</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span><span class="tok-w"> </span><span class="tok-n">version</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_characteristic"><code>Number_T characteristic</code></h5>
<div class="paragraph">
<p>The field&#8217;s prime modulus or "characteristic".
The parser does not check for primality.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-n">characteristic</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_degree"><code>size_t degree</code></h5>
<div class="paragraph">
<p>The field&#8217;s degree.
The IR requires this to be <code>1</code>, although the parser does not test this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">degree</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_resource"><code>wtk::Resource resource</code></h5>
<div class="paragraph">
<p>The resource type which is currently being parsed.
This has type <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Resource</span><span class="tok-w"> </span><span class="tok-n">resource</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">Resource</span><span class="tok-o">::</span><span class="tok-n">invalid</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_gateSet"><code>wtk::GateSet gateSet</code></h5>
<div class="paragraph">
<p>The set of gates to be allowed within the relation.
This has type <a href="api/wtk/IRParameters.html#struct_GateSet"><code>wtk::GateSet</code></a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">WARNING</dt>
<dd>
<p><code>gateSet</code> may only be used if <code>resource == wtk::Resource::relation</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">GateSet</span><span class="tok-w"> </span><span class="tok-n">gateSet</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_featureToggles"><code>wtk::FeatureToggles featureToggles</code></h5>
<div class="paragraph">
<p>The IR structural features to be allowed within the relation.
This has type <a href="api/wtk/IRParameters.html#struct_FeatureToggles"><code>wtk::FeatureToggles</code></a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">WARNING</dt>
<dd>
<p><code>featureToggles</code> may only be used if <code>resource == wtk::Resource::relation</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">FeatureToggles</span><span class="tok-w"> </span><span class="tok-n">featureToggles</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_arithmetic"><code>wtk::ArithemticParser&lt;Number_T&gt;* arithmetic()</code></h5>
<div class="paragraph">
<p>This method returns a delegate parser for an arithmetic resource.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">WARNING</dt>
<dd>
<p>When parsing a relation, use of an arithmetic parser for parsing a non-arithmetic gateset will result in parse errors.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ArithmeticParser</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w">  </span><span class="tok-n">arithmetic</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_arithmetic64"><code>wtk::ArithemticParser&lt;uint64_t&gt;* arithmetic()</code></h5>
<div class="paragraph">
<p>This method returns a delegate parser for an arithmetic resource. However the <code>Number_T</code> template is downgraded to a <code>uint64_t</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">WARNING</dt>
<dd>
<p>When parsing a relation, use of an arithmetic parser for parsing a non-arithmetic gateset will result in parse errors.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ArithmeticParser</span><span class="tok-o">&lt;</span><span class="tok-kt">uint64_t</span><span class="tok-o">&gt;*</span><span class="tok-w">  </span><span class="tok-n">arithmetic64</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_arithmetic32"><code>wtk::ArithemticParser&lt;uint32_t&gt;* arithmetic()</code></h5>
<div class="paragraph">
<p>This method returns a delegate parser for an arithmetic resource. However the <code>Number_T</code> template is downgraded to a <code>uint32_t</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">WARNING</dt>
<dd>
<p>When parsing a relation, use of an arithmetic parser for parsing a non-arithmetic gateset will result in parse errors.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ArithmeticParser</span><span class="tok-o">&lt;</span><span class="tok-kt">uint32_t</span><span class="tok-o">&gt;*</span><span class="tok-w">  </span><span class="tok-n">arithmetic32</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Parser_boolean"><code>wtk::BooleanParser* boolean()</code></h5>
<div class="paragraph">
<p>This method returns a delegate parser for a boolean resource.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>The <code>Number_T</code> template is removed for <code>wtk::BooleanParser</code>, and <code>uint8_t</code> is always used in its place.</p>
</dd>
<dt class="hdlist1">WARNING</dt>
<dd>
<p>When parsing a relation, use of a boolean parser for parsing a non-boolean gateset will result in parse errors.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">BooleanParser</span><span class="tok-o">*</span><span class="tok-w">  </span><span class="tok-nf">boolean</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_ArithmeticParser"><code>template&lt;typename Number_T&gt; struct ArithmeticParser</code></h4>
<div class="paragraph">
<p>This is a delegate parser for the body of an arithmetic IR resource.
Its interface is substantially similar to <a href="#struct_BooleanParser"><code>wtk::BooleanParser</code></a>.
In general, this type should not be constructed, but rather obtained from <a href="#Parser_arithmetic"><code>parser.arithmetic()</code></a>.</p>
</div>
<div class="sect4">
<h5 id="ArithmeticParser_parseStream"><code>bool parseStream(wtk::ArithmeticStreamHandler&lt;Number_T&gt;* handler)</code></h5>
<div class="paragraph">
<p>Parses the body of an arithmetic IR-Simple relation, passing each gate off to the handler in a streaming fashion.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::relation</code></a>.</p>
</div>
<div class="paragraph">
<p>The <a href="api/wtk/ArithmeticStreamHandler.html#class_ArithmeticStreamHandler"><code>handler</code></a> parameter must be nonnull.
The method returns <code>false</code> on failure, including if either the <a href="#Parser_gateSet"><code>parser.gateSet</code></a> or <a href="#Parser_featureToggles"><code>parser.featureToggles</code></a> are violated.
It does not make any other well-formedness checks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">parseStream</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ArithmeticStreamHandler</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">handler</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticParser_parseTree"><code>wtk:IRTree&lt;Number_T&gt; parseTree()</code></h5>
<div class="paragraph">
<p>Parses the body of any arithmetic relation, constructing a <a href="api/wtk/IRTree.html#api_IRTree">syntax tree</a>.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::relation</code></a>.
If a parse failure occurs, <code>nullptr</code> is returned, including if either the <a href="#Parser_gateSet"><code>parser.gateSet</code></a> or <a href="#Parser_featureToggles"><code>parser.featureToggles</code></a> are violated.
It does not make any other well-formedness checks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">parseTree</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticParser_instance"><code>wtk::InputStream&lt;Number_T&gt;* instance()</code></h5>
<div class="paragraph">
<p>Returns an <a href="#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;*</code></a> which will parse the instance one value at a time.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::instance</code></a>.</p>
</div>
<div class="paragraph">
<p>This method will never return <code>nullptr</code>, instead returned <a href="#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;*</code></a> will return <a href="#enum_StreamStatus"><code>wtk::StreamStatus::error</code></a> as necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticParser_shortWitness"><code>wtk::InputStream&lt;Number_T&gt;* shortWitness()</code></h5>
<div class="paragraph">
<p>Returns an <a href="#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;*</code></a> which will parse the short witness one value at a time.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::shortWitness</code></a>.</p>
</div>
<div class="paragraph">
<p>This method will never return <code>nullptr</code>, instead returned <a href="#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;*</code></a> will return <a href="#enum_StreamStatus"><code>wtk::StreamStatus::error</code></a> as necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">shortWitness</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_BooleanParser"><code>struct BooleanParser</code></h4>
<div class="paragraph">
<p>This is a delegate parser for the body of an boolean IR resource.
Its interface is substantially similar to <a href="#struct_AritheticParser"><code>wtk::ArithmeticParser&lt;Number_T&gt;</code></a>.
In general, this type should not be constructed, but rather obtained from <a href="#Parser_boolean"><code>parser.boolean()</code></a>.
Note that this struct is not parameterized by <code>Number_T</code>.
Instead anywhere the a field/numeric literal would be expected, <code>uint8_t</code> is used instead.</p>
</div>
<div class="sect4">
<h5 id="BooleanParser_parseStream"><code>bool parseStream(wtk::BooleanStreamHandler* handler)</code></h5>
<div class="paragraph">
<p>Parses the body of an boolean IR-Simple relation, passing each gate off to the handler in a streaming fashion.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::relation</code></a>.</p>
</div>
<div class="paragraph">
<p>The <a href="api/wtk/BooleanStreamHandler.html#class_BooleanStreamHandler"><code>handler</code></a> parameter must be nonnull.
The method returns <code>false</code> on failure, including if either the <a href="#Parser_gateSet"><code>parser.gateSet</code></a> or <a href="#Parser_featureToggles"><code>parser.featureToggles</code></a> are violated.
It does not make any other well-formedness checks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">parseStream</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">BooleanStreamHandler</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">handler</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanParser_parseTree"><code>wtk:IRTree&lt;uint8_t&gt; parseTree()</code></h5>
<div class="paragraph">
<p>Parses the body of any arithmetic relation, constructing a <a href="api/wtk/IRTree.html#api_IRTree">syntax tree</a>.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::relation</code></a>.
If a parse failure occurs, <code>nullptr</code> is returned, including if either the <a href="#Parser_gateSet"><code>parser.gateSet</code></a> or <a href="#Parser_featureToggles"><code>parser.featureToggles</code></a> are violated.
It does not make any other well-formedness checks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">parseTree</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanParser_instance"><code>wtk::InputStream&lt;uint8_t&gt;* instance()</code></h5>
<div class="paragraph">
<p>Returns an <a href="#struct_InputStream"><code>wtk::InputStream&lt;uint8_t&gt;*</code></a> which will parse the instance one value at a time.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::instance</code></a>.</p>
</div>
<div class="paragraph">
<p>This method will never return <code>nullptr</code>, instead returned <a href="#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;*</code></a> will return <a href="#enum_StreamStatus"><code>wtk::StreamStatus::error</code></a> as necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanParser_shortWitness"><code>wtk::InputStream&lt;uint8_t&gt;* shortWitness()</code></h5>
<div class="paragraph">
<p>Returns an <a href="#struct_InputStream"><code>wtk::InputStream&lt;uint8_t&gt;*</code></a> which will parse the short witness one value at a time.
The <a href="#Parser_resource"><code>parser.resource</code></a> must be <a href="api/wtk/IRParameters.html#enum_Resource"><code>wtk::Resource::shortWitness</code></a>.</p>
</div>
<div class="paragraph">
<p>This method will never return <code>nullptr</code>, instead returned <a href="#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;*</code></a> will return <a href="#enum_StreamStatus"><code>wtk::StreamStatus::error</code></a> as necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">shortWitness</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_InputStream"><code>template&lt;typename Number_T&gt; struct InputStream</code></h4>
<div class="paragraph">
<p>The InputStream represents either an instance or a short witness, and and allows the user to consume one value at a time from the stream.
Do not attempt to construct one manually.
Instead retrieve one from <a href="#ArithmeticParser_instance"><code>arithmeticParser.instance()</code></a>, <a href="#ArithmeticParser_shortWitness"><code>arithmeticParser.shortWitness()</code></a>, <a href="#BooleanParser_instance"><code>booleanParser.instance()</code></a>,  or <a href="#BooleanParser_shortWitness"><code>booleanParser.shortWitness()</code></a>.</p>
</div>
<div class="sect4">
<h5 id="InputStream_next"><code>StreamStatus next(Number_T* num)</code></h5>
<div class="paragraph">
<p>Consumes a single value from the stream, placing it in the <code>num</code> parameter.
This operation may fail if a parse error or the end of file is reached, returning an <a href="#enum_StreamStatus"><code>wtk::StreamStatus</code></a>  error code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">StreamStatus</span><span class="tok-w"> </span><span class="tok-nf">next</span><span class="tok-p">(</span><span class="tok-n">Number_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">num</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="InputStream_lineNum"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>If the parser supports line numbering, then this method returns the line number corresponding to the prior invocation of <code>this&#8594;next(&#8230;&#8203;)</code>.
If line numbering is not supported then <code>0</code> is returned.</p>
</div>
<div class="paragraph">
<p>If <code>this&#8594;next(&#8230;&#8203;)</code> has not been called, it returned <code>wtk::StreamStatus::end</code>, or it returned <code>wtk::StreamStatus::error</code> then <code>this&#8594;lineNum()</code> may return any of <code>0</code>, the line number on which the error or end occurred, or the line number of the most recent successful call to <code>this&#8594;next(&#8230;&#8203;)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enum_StreamStatus"><code>enum StreamStatus</code></h4>
<div class="paragraph">
<p>This enumeration indicates the success or means of failure for an <a href="#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;</code></a>.
It may take one of the following values.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::StreamStatus::success</code></dt>
<dd>
<p>Successfully retrieved an item from the stream.</p>
</dd>
<dt class="hdlist1"><code>wtk::StreamStatus::end</code></dt>
<dd>
<p>Reached the end of the stream.</p>
</dd>
<dt class="hdlist1"><code>wtk::StreamStatus::error</code></dt>
<dd>
<p>A parse error occurred.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_IRTree">IR Tree API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/IRTree.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The IR Tree API is parameterized on a <code>Number_T</code> template.
<code>Number_T</code> should be integer-like enough to be parsed from a string.
This API is abstract and implemented by parsers for various IR formats.
As an abstract interface many "attributes" must be accessed through accessor methods due to different storage methods of various IR formats.</p>
</div>
<div class="paragraph">
<p>At a top level, the <a href="#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> is the root of an abstract syntax tree for a <em>relation</em> in the SIEVE IR.
The <a href="#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;</code></a> defines scope block within the AST and other structs such as <a href="#struct_BinaryGate"><code>wtk::BinaryGate</code></a> defining individual directives.</p>
</div>
<div class="paragraph">
<p>Pointer members provided by the IR Tree API may be expected to be nonnull, taking the lifetime of the <a href="api/wtk/Parser.html#api_Parser">parser</a> which provided a top-level <a href="#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;*</code></a>.
However, as defined by the parser, the <code>wtk::IRTree&lt;Number_T&gt;*</code> may itself be null.
The parser retains ownership of all objects from this API, the caller may not <code>free(&#8230;&#8203;)</code> them.</p>
</div>
<div class="sect3">
<h4 id="struct_IRTree"><code>template&lt;typename Number_T&gt; struct IRTree</code></h4>
<div class="paragraph">
<p>The <code>wtk::IRTree&lt;Number_T&gt;</code> struct is the root of an IR syntax tree.
The encapsulates both a list of named functions and the top-level scope of an IR relation.</p>
</div>
<div class="sect4">
<h5 id="IRTree_size"><code>size_t size()</code></h5>
<div class="paragraph">
<p>This method indicates how many named function declarations are defined by this relation.
It is an integer greater than or equal to <code>0</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">size</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IRTree_functionDeclare"><code>wtk::FunctionDeclare&lt;Number_T&gt;* functionDeclare(size_t n)</code></h5>
<div class="paragraph">
<p>Retrieve a named function declaration by index.
<code>n</code> must be between <code>0</code> (inclusive) and <code>this&#8594;size()</code> (exclusive) or else undefined behavior occurs.
It returns a nonnull <a href="#struct_FunctionDeclare"><code>wtk::FunctionDeclare&lt;Number_T&gt;*</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">FunctionDeclare</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">functionDeclare</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IRTree_body"><code>wtk::DirectiveList&lt;Number_T&gt;* body()</code></h5>
<div class="paragraph">
<p>Retrieve the body of the relation.
It returns a nonnull <a href="#struct_DirectiveList"><code>wtk::DirectiveList&lt;Number_T&gt;*</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">body</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IRTree_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the IRTree begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_DirectiveList"><code>template&lt;typename Number_T&gt; struct DirectiveList</code></h4>
<div class="paragraph">
<p>The <code>wtk::DirectiveList&lt;Number_T&gt;</code> is a list type for directives.
Since directives must be differentiated, each index of the list has a tag indicating a type, through which the element must be retrieved.</p>
</div>
<div class="sect4">
<h5 id="DirectiveList_size"><code>size_t size()</code></h5>
<div class="paragraph">
<p>Indicates the number of elements in the list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">size</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_enum_Type"><code>enum Type</code></h5>
<div class="paragraph">
<p>This enumerates the various types which an element may take.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::BINARY_GATE</code></dt>
<dd>
<p>corresponds to <a href="#struct_BinaryGate"><code>wtk::BinaryGate</code></a> and <a href="#DirectiveList_binaryGate"><code>this&#8594;binaryGate(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::UNARY_GATE</code></dt>
<dd>
<p>corresponds to <a href="#struct_UnaryGate"><code>wtk::UnaryGate</code></a> and <a href="#DirectiveList_unaryGate"><code>this&#8594;unaryGate(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::BINARY_CONST_GATE</code></dt>
<dd>
<p>corresponds to <a href="#struct_BinaryConstGate"><code>wtk::BinaryConstGate&lt;Number_T&gt;</code></a> and <a href="#DirectiveList_binaryConstGate"><code>this&#8594;binaryConstGate(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::INPUT</code></dt>
<dd>
<p>corresponds to <a href="#struct_Input"><code>wtk::Input</code></a> and <a href="#DirectiveList_input"><code>this&#8594;input(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::ASSIGN</code></dt>
<dd>
<p>corresponds to <a href="#struct_Assign"><code>wtk::Assign&lt;Number_T&gt;</code></a> and <a href="#DirectiveList_assign"><code>this&#8594;assign(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::ASSERT_ZERO</code></dt>
<dd>
<p>corresponds to <a href="#struct_Terminal">a <code>wtk::Terminal</code> when used for the <code>@assert_zero</code> gate</a> and <a href="#DirectiveList_assertZero"><code>this&#8594;assertZero(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::DELETE_SINGLE</code></dt>
<dd>
<p>corresponds to <a href="#struct_Terminal">a <code>wtk::Terminal</code> when used for a <code>@delete</code> directive</a> and <a href="#DirectiveList_deleteSingle"><code>this&#8594;deleteSingle(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::DELETE_RANGE</code></dt>
<dd>
<p>corresponds to <a href="#struct_WireRange">an <code>wtk::WireRange</code> when used for a <code>@delete</code> directive</a> and <a href="#DirectiveList_deleteRange"><code>this&#8594;deleteRange(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::FUNCTION_INVOKE</code></dt>
<dd>
<p>corresponds to <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a> and <a href="#DirectiveList_functionInvoke"><code>this&#8594;functionInvoke(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::ANON_FUNCTION</code></dt>
<dd>
<p>corresponds to <a href="#struct_AnonFunction"><code>wtk::AnonFunction&lt;Number_T&gt;</code></a> and <a href="#DirectiveList_anonFunction"><code>this&#8594;anonFunction(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::FOR_LOOP</code></dt>
<dd>
<p>corresponds to <a href="#struct_ForLoop"><code>wtk::ForLoop&lt;Number_T&gt;</code></a> and <a href="#DirectiveList_forLoop"><code>this&#8594;forLoop(n)</code></a>.</p>
</dd>
<dt class="hdlist1"><code>wtk::DirectiveList&lt;Number_T&gt;::SWITCH_STATEMENT</code></dt>
<dd>
<p>corresponds to <a href="#struct_SwitchStatement"><code>wtk::SwitchStatement&lt;Number_T&gt;</code></a> and <a href="#DirectiveList_switchStatement"><code>this&#8594;switchStatement(n)</code></a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_type"><code>wtk::DirectiveList&lt;Number_T&gt;::Type type(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the <a href="#DirectiveList_enum_Type">type</a> of the nth element in this list.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; this&#8594;size()</code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Type</span><span class="tok-w"> </span><span class="tok-nf">type</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_binaryGate"><code>wtk::BinaryGate* binaryGate(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_BinaryGate"><code>wtk::BinaryGate</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::BINARY_GATE</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">BinaryGate</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">binaryGate</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_unaryGate"><code>wtk::UnaryGate* unaryGate(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_UnaryGate"><code>wtk::UnaryGate</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::UNARY_GATE</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">UnaryGate</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">unaryGate</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_binaryConstGate"><code>wtk::BinaryConstGate&lt;Number_T&gt;* binaryConstGate(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_BinaryConstGate"><code>wtk::BinaryConstGate&lt;Number_T&gt;</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::BINARY_CONST_GATE</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">BinaryConstGate</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">binaryConstGate</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_input"><code>wtk::Input* input(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_Input"><code>wtk::Input</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::INPUT</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Input</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">input</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_assign"><code>wtk::Assign&lt;Number_T&gt;* assign(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_Assign"><code>wtk::Assign&lt;Number_T&gt;</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::ASSIGN</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Assign</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">assign</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_assertZero"><code>wtk::Terminal* assertZero(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_Terminal"><code>wtk::Terminal</code></a> type for the purpose of an <code>@assert_zero</code> gate.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::ASSERT_ZERO</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Terminal</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">assertZero</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_deleteSingle"><code>wtk::Terminal* deleteSingle(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_Terminal"><code>wtk::Terminal</code></a> type for the purpose of a <code>@delete</code> gate.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::DELETE_SINGLE</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">Terminal</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">deleteSingle</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_deleteRange"><code>wtk::WireRange* deleteRange(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_WireRange"><code>wtk::WireRange</code></a> type for the purpose of a <code>@delete</code> gate.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::DELETE_RANGE</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireRange</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">deleteRange</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_functionInvoke"><code>wtk::FunctionInvoke* functionInvoke(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::FUNCTION_INVOKE</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">FunctionInvoke</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">functionInvoke</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_anonFunction"><code>wtk::AnonFunction&lt;Number_T&gt;* anonFunction(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_AnonFunction"><code>wtk::AnonFunction&lt;Number_T&gt;</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::ANON_FUNCTION</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">AnonFunction</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">anonFunction</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_forLoop"><code>wtk::ForLoop&lt;Number_T&gt;* forLoop(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_ForLoop"><code>wtk::ForLoop&lt;Number_T&gt;</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::FOR_LOOP</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">ForLoop</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">forLoop</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_switchStatement"><code>wtk::SwitchStatement&lt;Number_T&gt;* switchStatement(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element as a <a href="#struct_SwitchhStatement"><code>wtk::SwitchStatement&lt;Number_T&gt;</code></a> type.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#DirectiveList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#DirectiveList_type">this&#8594;type(n)</a> == <a href="#DirectiveList_enum_Type">wtk::DirectiveList&lt;Number_T&gt;::SWITCH_STATEMENT</a></code> otherwise undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">SwitchStatement</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">switchStatement</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="DirectiveList_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the DirectiveList begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_BinaryGate"><code>struct BinaryGate</code></h4>
<div class="paragraph">
<p>This represents a binary gate in the IR. Binary refers to the two-input wires of this gate, not numeric representation.
It has methods for left and right input wires as well as the output wire.
The specific gate type is the <a href="#BinaryGate_enum_Calculation"><code>Calculation</code></a> enum.</p>
</div>
<div class="sect4">
<h5 id="BinaryGate_enum_Calculation"><code>enum Calculation</code></h5>
<div class="paragraph">
<p>Indicates what calculation this gate performs.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::BinaryGate::AND</code></dt>
<dd>
<p><code>@and</code></p>
</dd>
<dt class="hdlist1"><code>wtk::BinaryGate::XOR</code></dt>
<dd>
<p><code>@xor</code></p>
</dd>
<dt class="hdlist1"><code>wtk::BinaryGate::ADD</code></dt>
<dd>
<p><code>@add</code></p>
</dd>
<dt class="hdlist1"><code>wtk::BinaryGate::MUL</code></dt>
<dd>
<p><code>@mul</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="BinaryGate_calculation"><code>wtk::BinaryGate::Calculation calculation()</code></h5>
<div class="paragraph">
<p>returns which calculation the binary gate performs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Calculation</span><span class="tok-w"> </span><span class="tok-nf">calculation</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryGate_outputWire"><code>wtk::index_t outputWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s output wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">outputWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryGate_leftWire"><code>wtk::index_t leftWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s left input wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">leftWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryGate_rightWire"><code>wtk::index_t rightWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s right input wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">rightWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryGate_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the binary gate begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_UnaryGate"><code>struct UnaryGate</code></h4>
<div class="paragraph">
<p>This represents a unary gate in the IR. Unary refers to the single input wire of this gate, not numeric representation.
It has methods for the input wire as well as the output wire.
The specific gate type is the <a href="#UnaryGate_enum_Calculation"><code>Calculation</code></a> enum.</p>
</div>
<div class="sect4">
<h5 id="UnaryGate_enum_Calculation"><code>enum Calculation</code></h5>
<div class="paragraph">
<p>Indicates what calculation this gate performs.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::UnaryGate::NOT</code></dt>
<dd>
<p><code>$0 &#8592; @not($1)</code></p>
</dd>
<dt class="hdlist1"><code>wtk::UnaryGate::COPY</code></dt>
<dd>
<p><code>$0 &#8592; $1</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="UnaryGate_calculation"><code>wtk::UnaryGate::Calculation calculation()</code></h5>
<div class="paragraph">
<p>returns which calculation the unary gate performs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Calculation</span><span class="tok-w"> </span><span class="tok-nf">calculation</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="UnaryGate_outputWire"><code>wtk::index_t outputWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s output wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">outputWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="UnaryGate_inputWire"><code>wtk::index_t rightWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s input wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">inputWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="UnaryGate_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the unary gate begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_BinaryConstGate"><code>template&lt;typename Number_T&gt; struct BinaryConstGate</code></h4>
<div class="paragraph">
<p>This represents a binary constant gate in the IR. Binary refers to the input wire and input constant of this gate, not numeric representation.
It has methods for left input wire and right input constant as well as the output wire.
The specific gate type is the <a href="#BinaryConstGate_enum_Calculation"><code>Calculation</code></a> enum.</p>
</div>
<div class="sect4">
<h5 id="BinaryConstGate_enum_Calculation"><code>enum Calculation</code></h5>
<div class="paragraph">
<p>Indicates what calculation this gate performs.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::BinaryConstGate&lt;Number_T&gt;::ADDC</code></dt>
<dd>
<p><code>@addc</code></p>
</dd>
<dt class="hdlist1"><code>wtk::BinaryConstGate&lt;Number_T&gt;::MULC</code></dt>
<dd>
<p><code>@mulc</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="BinaryConstGate_calculation"><code>wtk::BinaryConstGate&lt;Number_T&gt;::Calculation calculation()</code></h5>
<div class="paragraph">
<p>returns which calculation the binary gate performs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Calculation</span><span class="tok-w"> </span><span class="tok-nf">calculation</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryConstGate_outputWire"><code>wtk::index_t outputWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s output wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">outputWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryConstGate_leftWire"><code>wtk::index_t leftWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s left input wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">leftWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryConstGate_rightWire"><code>wtk::index_t rightWire()</code></h5>
<div class="paragraph">
<p>Returns the gate&#8217;s right input constant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-nf">rightValue</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BinaryConstGate_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the binary constant gate begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_Input"><code>struct Input</code></h4>
<div class="paragraph">
<p>Represents an input directive (either <code>@instance</code> or <code>@short_witness</code>).
the <a href="#Input_enum_Stream"><code>Stream</code></a> enumeration indicates from which stream to consume.</p>
</div>
<div class="sect4">
<h5 id="Input_enum_Stream"><code>enum Stream</code></h5>
<div class="paragraph">
<p>An enumeration of the IR stream resources.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::Input::INSTANCE</code></dt>
<dd>
<p><code>@instance</code></p>
</dd>
<dt class="hdlist1"><code>wtk::Input::SHORT_WITNESS</code></dt>
<dd>
<p><code>@short_witness</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="Input_stream"><code>wtk::Input::Stream stream()</code></h5>
<div class="paragraph">
<p>Returns the <a href="#Input_enum_Stream">stream</a> from which this directive is to consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Stream</span><span class="tok-w"> </span><span class="tok-nf">stream</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Input_outputWire"><code>wtk::index_t outputWire()</code></h5>
<div class="paragraph">
<p>Returns the stream consumption&#8217;s output wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">outputWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Input_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the input directive begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_Assign"><code>template&lt;typename Number_T&gt; struct Assign</code></h4>
<div class="paragraph">
<p>A directive that assigns a constant value to an output wire.</p>
</div>
<div class="sect4">
<h5 id="Assign_outputWire"><code>wtk::index_t outputWire()</code></h5>
<div class="paragraph">
<p>Returns the assign directive&#8217;s output wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">outputWire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Assign_constValue"><code>Number_T constValue()</code></h5>
<div class="paragraph">
<p>Returns the assign directive&#8217;s constant input value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-nf">constValue</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Assign_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the assign directive begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_Terminal"><code>struct Terminal</code></h4>
<div class="paragraph">
<p>Represents a directive with just a single input wire.
Its name is derived from the fact that it has no output wires, thus "terminating" some sequence of gates.
It is used by the directives <code>@assert_zero</code> and <code>@delete</code> (for a single input wire), although they are distinguished by <a href="#DirectiveList_enum_Type"><code>wtk::DirectiveList&lt;Number_T&gt;::Type</code></a> rather than an enumeration within <code>struct Terminal</code>.</p>
</div>
<div class="sect4">
<h5 id="Terminal_wire"><code>wtk::index_t wire()</code></h5>
<div class="paragraph">
<p>Returns the terminal&#8217;s single input wire.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">wire</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Terminal_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the terminal begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_WireRange"><code>struct WireRange</code></h4>
<div class="paragraph">
<p>Represents a range of wires in the IR.
It is used for the range form of the <code>@delete</code> directive, as well as a component of the <a href="#struct_WireList"><code>wtk::WireList</code></a>.</p>
</div>
<div class="sect4">
<h5 id="WireRange_first()"><code>wtk::index_t first()</code></h5>
<div class="paragraph">
<p>Returns the first wire in the range (consider it inclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">first</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="WireRange_last()"><code>wtk::index_t last()</code></h5>
<div class="paragraph">
<p>Returns the last wire in the range (consider it inclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">last</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="WireRange_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the wire range begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_WireList"><code>struct WireList</code></h4>
<div class="paragraph">
<p>The IR uses wire lists for holding parameters and returns to function-gates.
These lists are "ranged" such that the elements of the list do not correspond to the length of the list.
Some elements are individual wires, whereas other elements are ranges of wires.
Element type is given by the <a href="#WireList_enum_Type"><code>Type</code></a> enumeration.</p>
</div>
<div class="sect4">
<h5 id="WireList_size"><code>size_t size()</code></h5>
<div class="paragraph">
<p>Indicates how many <em>elements</em> are in the list (does not necessarily correspond to <em>wire count</em>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">size</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="WireList_enum_Type"><code>enum Type</code></h5>
<div class="paragraph">
<p>Indicates if an element a single or a range element.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wtk::WireList::SINGLE</code></p>
</li>
<li>
<p><code>wtk::WireList::RANGE</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="WireList_type"><code>wtk::WireList::Type type(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the type of the nth element.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#WireList_size">this&#8594;size()</a></code> or else undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Type</span><span class="tok-w"> </span><span class="tok-nf">type</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="WireList_single"><code>wtk::index_t single(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element in the list as a single element.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#WireList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#WireList_type">this&#8594;type(n)</a> == <a href="#WireList_enum_Type">wtk::WireList::SINGLE</a></code> or else undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">single</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="WireList_range"><code>wtk::WireRange* range(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element in the list as a <a href="#struct_WireRange">range</a> element.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#WireList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#WireList_type">this&#8594;type(n)</a> == <a href="#WireList_enum_Type">wtk::WireList::RANGE</a></code> or else undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireRange</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">range</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="WireList_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the wire list begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_FunctionDeclare"><code>template&lt;typename Number_T&gt; struct FunctionDeclare</code></h4>
<div class="paragraph">
<p>This <code>wtk::FunctionDeclare&lt;Number_T&gt;</code> is the definition of a named function-gate.
It pairs with <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a> for invocation.
They should be matched to eachother by a name (as a <code>char*</code>).</p>
</div>
<div class="sect4">
<h5 id="FunctionDeclare_name"><code>char const* name()</code></h5>
<div class="paragraph">
<p>Returns the name of the function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">name</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionDeclare_outputCount"><code>wtk::index_t outputCount()</code></h5>
<div class="paragraph">
<p>Returns the number of output wires this function gate expects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">outputCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionDeclare_inputCount"><code>wtk::index_t inputCount()</code></h5>
<div class="paragraph">
<p>Returns the number of input wires this function gate expects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">inputCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionDeclare_instanceCount"><code>wtk::index_t instanceCount()</code></h5>
<div class="paragraph">
<p>Returns the number of instance values this function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">instanceCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionDeclare_shortWitnessCount"><code>wtk::index_t shortWitnessCount()</code></h5>
<div class="paragraph">
<p>Returns the number of short witness values this function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">shortWitnessCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionDeclare_body"><code>wtk::DirectiveList&lt;Number_T&gt;* body()</code></h5>
<div class="paragraph">
<p>returns the body of the function gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">body</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionDeclare_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_FunctionInvoke"><code>struct FunctionInvoke</code></h4>
<div class="paragraph">
<p>The <code>wtk:FunctionInvoke</code> invokes a function gate, carrying a name which should match with the name of a <a href="#struct_FunctionDeclare"><code>wtk::FunctionDeclare&lt;Number_T&gt;</code></a>.</p>
</div>
<div class="sect4">
<h5 id="FunctionInvoke_name"><code>char const* name()</code></h5>
<div class="paragraph">
<p>Returns the name of the function gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">name</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionInvoke_outputList"><code>wtk::WireList* outputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_WireList"><code>wtk::WireList</code></a> for the output wires of this invocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">outputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionInvoke_inputList"><code>wtk::WireList* inputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_WireList"><code>wtk::WireList</code></a> for the input wires of this invocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">inputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="FunctionInvoke_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the function invocation begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_AnonFunction"><code>template&lt;typename Number_T&gt; struct AnonFunction</code></h4>
<div class="paragraph">
<p>The <code>wtk::AnonFunction&lt;Number_T&gt;</code> is the simultaneous declaration and invocation of an anonymous function-gate.
It mirrors the structure of both <a href="#struct_FunctionDeclare"><code>wtk::FunctionDeclare&lt;Number_T&gt;</code></a> and <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a>, although without certain attributes such as <code>name()</code>.</p>
</div>
<div class="sect4">
<h5 id="AnonFunction_outputList"><code>wtk::WireList* outputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_WireList"><code>wtk::WireList</code></a> for the output wires of this anonymous function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">outputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="AnonFunction_inputList"><code>wtk::WireList* inputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_WireList"><code>wtk::WireList</code></a> for the input wires of this anonymous function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">inputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="AnonFunction_instanceCount"><code>wtk::index_t instanceCount()</code></h5>
<div class="paragraph">
<p>Returns the number of instance values this anonymous function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">instanceCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="AnonFunction_shortWitnessCount"><code>wtk::index_t shortWitnessCount()</code></h5>
<div class="paragraph">
<p>Returns the number of short witness values this anonymous function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">shortWitnessCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="AnonFunction_body"><code>wtk::DirectiveList&lt;Number_T&gt;* body()</code></h5>
<div class="paragraph">
<p>returns the body of the anonymous function gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">body</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="AnonFunction_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the anonymous function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_IterExpr"><code>struct IterExpr</code></h4>
<div class="paragraph">
<p>The <code>wtk::IterExpr</code> takes the place of <code>wtk::index_t</code> in input and output lists of <a href="#struct_ForLoop">For Loop</a> bodies.
Instead of representing an exact wire-index, these expressions evaluate to a wire-index, allowing the loop to traverse ranges of wires.</p>
</div>
<div class="paragraph">
<p>All iterator expressions are carried out over <code>wtk::index_t</code>.
The expressions are a recursive datatype, with base cases for numeric literals and loop-iterators.
Recursive cases exist for addition, subtraction, multiplication, and division by a constant.
The expression type is given by <a href="#IterExpr_enum_Type"><code>enum Type</code></a>.</p>
</div>
<div class="sect4">
<h5 id="IterExpr_enum_Type"><code>enum Type</code></h5>
<div class="paragraph">
<p>This enumerates the various types of expressions.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::IterExpr::LITERAL</code></dt>
<dd>
<p>A numeric literal</p>
</dd>
<dt class="hdlist1"><code>wtk::IterExpr::ITERATOR</code></dt>
<dd>
<p>A reference to a loop iterator</p>
</dd>
<dt class="hdlist1"><code>wtk::IterExpr::ADD</code></dt>
<dd>
<p>Addition expression of two sub-expressions</p>
</dd>
<dt class="hdlist1"><code>wtk::IterExpr::SUB</code></dt>
<dd>
<p>Subtraction expression of two sub-expressions</p>
</dd>
<dt class="hdlist1"><code>wtk::IterExpr::MUL</code></dt>
<dd>
<p>Multiplition expression of two sub-expressions</p>
</dd>
<dt class="hdlist1"><code>wtk::IterExpr::DIV</code></dt>
<dd>
<p>Division expression of one sub-expression and a constant divisor</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="IterExpr_type"><code>wtk:IterExpr::Type type()</code></h5>
<div class="paragraph">
<p>Returns the type of this expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Type</span><span class="tok-w"> </span><span class="tok-nf">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExpr_literal"><code>wtk::index_t literal()</code></h5>
<div class="paragraph">
<p>Returns this literal expression or the right-hand-side of this division expression as a <code>wtk::index_t</code>.
If the following precondition isn&#8217;t met, then undefined behavior occurs (see also <a href="#IterExpr_type"><code>this&#8594;type()</code></a> and <a href="#IterExpr_enum_Type"><code>enum Type</code></a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">LITERAL</span>
<span class="tok-w">  </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">DIV</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">literal</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExpr_name"><code>char const* name()</code></h5>
<div class="paragraph">
<p>Returns this loop-iterator expression as a <code>char*</code>.
If the following precondition isn&#8217;t met, then undefined behavior occurs (see also <a href="#IterExpr_type"><code>this&#8594;type()</code></a> and <a href="#IterExpr_enum_Type"><code>enum Type</code></a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">ITERATOR</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">literal</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExpr_lhs"><code>wtk::IterExpr* lhs()</code></h5>
<div class="paragraph">
<p>Returns the left-hand-side of this expression.
If the following precondition isn&#8217;t met, then undefined behavior occurs (see also <a href="#IterExpr_type"><code>this&#8594;type()</code></a> and <a href="#IterExpr_enum_Type"><code>enum Type</code></a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">ADD</span>
<span class="tok-w">  </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">SUB</span>
<span class="tok-w">  </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">MUL</span>
<span class="tok-w">  </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">DIV</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">IterExpr</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">lhs</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExpr_rhs"><code>wtk::IterExpr* lhs()</code></h5>
<div class="paragraph">
<p>Returns the right-hand-side of this expression.
If the following precondition isn&#8217;t met, then undefined behavior occurs (see also <a href="#IterExpr_type"><code>this&#8594;type()</code></a> and <a href="#IterExpr_enum_Type"><code>enum Type</code></a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">ADD</span>
<span class="tok-w">  </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">SUB</span>
<span class="tok-w">  </span><span class="tok-o">||</span><span class="tok-w"> </span><span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">type</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">==</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">::</span><span class="tok-n">MUL</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">IterExpr</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">lhs</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExpr_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the iterator expression begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_IterExprWireRange"><code>struct IterExprWireRange</code></h4>
<div class="paragraph">
<p>Represents a range of iterator expressions, mirroring the form of <a href="#struct_WireRange"><code>wtk::WireRange</code></a>.
It is used as a component of the <a href="#struct_IterExprWireList"><code>wtk::IterExprWireList</code></a> (which itself mirrors <a href="#struct_WireList"><code>wtk::WireList</code></a>).</p>
</div>
<div class="sect4">
<h5 id="IterExprWireRange_first()"><code>wtk::IterExpr* first()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_IterExpr"><code>wtk::IterExpr</code></a> for the first wire in the range (consider it inclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">first</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprWireRange_last()"><code>wtk::IterExpr* last()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_IterExpr"><code>wtk::IterExpr</code></a> for the last wire in the range (consider it inclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">last</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprWireRange_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the wire range begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_IterExprWireList"><code>struct IterExprWireList</code></h4>
<div class="paragraph">
<p>Represents a list of iterator expressions, mirroring the form of <a href="#struct_WireList"><code>wtk::WireList</code></a>.
For for-loop bodies, the input and output wire lists use these to enable traversal based on the loop iterator.</p>
</div>
<div class="paragraph">
<p>These lists are "ranged" such that the elements of the list do not correspond to the length of the list.
Some elements are individual expressions, whereas other elements are ranges of expressions.
Element type is given by the <a href="#IterExprWireList_enum_Type"><code>Type</code></a> enumeration.</p>
</div>
<div class="sect4">
<h5 id="IterExprWireList_size"><code>size_t size()</code></h5>
<div class="paragraph">
<p>Indicates how many <em>elements</em> are in the list (does not necessarily correspond to <em>wire count</em>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">size</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprWireList_enum_Type"><code>enum Type</code></h5>
<div class="paragraph">
<p>Indicates if an element a single or a range element.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wtk::IterExprWireList::SINGLE</code></p>
</li>
<li>
<p><code>wtk::IterExprWireList::RANGE</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="IterExprWireList_type"><code>wtk::IterExprWireList::Type type(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the type of the nth element.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#IterExprWireList_size">this&#8594;size()</a></code> or else undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Type</span><span class="tok-w"> </span><span class="tok-nf">type</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprWireList_single"><code>wtk::ItereExpr* single(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element in the list as a single element.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#IterExprWireList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#IterExprWireList_type">this&#8594;type(n)</a> == <a href="#IterExprWireList_enum_Type">wtk::IterExprWireList::SINGLE</a></code> or else undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExpr</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">single</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprWireList_range"><code>wtk::IterExprWireRange* range(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the nth element in the list as a <a href="#struct_IterExprWireRange">range</a> element.
<code>n</code> must be in the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#IterExprWireList_size">this&#8594;size()</a></code> and <code>n</code> must have the type <code><a href="#IterExprWireList_type">this&#8594;type(n)</a> == <a href="#IterExprWireList_enum_Type">wtk::IterExprWireList::RANGE</a></code> or else undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireRange</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">range</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprWireList_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the wire list begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_IterExprFunctionInvoke"><code>struct IterExprFunctionInvoke</code></h4>
<div class="paragraph">
<p>The <code>wtk:IterExprFunctionInvoke</code> invokes a function gate as the body of a for-loop, carrying a name which should match with the name of a <a href="#struct_FunctionDeclare"><code>wtk::FunctionDeclare&lt;Number_T&gt;</code></a>.
It mirrors <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a> replacing input and output lists with <a href="#struct_IterExprWireList"><code>wtk::IterExprWireList</code></a>.</p>
</div>
<div class="sect4">
<h5 id="IterExprFunctionInvoke_name"><code>char const* name()</code></h5>
<div class="paragraph">
<p>Returns the name of the function gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">name</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprFunctionInvoke_outputList"><code>wtk::IterExprWireList* outputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_IterExprWireList"><code>wtk::IterExprWireList</code></a> for the output wires of this invocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExprWireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">outputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprFunctionInvoke_inputList"><code>wtk::IterExprWireList* inputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_IterExprWireList"><code>wtk::IterExprWireList</code></a> for the input wires of this invocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExprWireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">inputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprFunctionInvoke_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the function invocation begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_IterExprAnonFunction"><code>template&lt;typename Number_T&gt; struct IterExprAnonFunction</code></h4>
<div class="paragraph">
<p>The <code>wtk::IterExprAnonFunction&lt;Number_T&gt;</code> is the simultaneous declaration and invocation of an anonymous function-gate as the body of a for-loop.
It mirrors the structure of both <a href="#struct_FunctionDeclare"><code>wtk::FunctionDeclare&lt;Number_T&gt;</code></a> and <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a>, although without certain attributes such as <code>name()</code>, and with the input and output lists replaced by <a href="#struct_IterExprWireList"><code>wtk::IterExprWireList</code></a></p>
</div>
<div class="sect4">
<h5 id="IterExprAnonFunction_outputList"><code>wtk::IterExprWireList* outputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_IterExprWireList"><code>wtk::IterExprWireList</code></a> for the output wires of this anonymous function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExprWireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">outputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprAnonFunction_inputList"><code>wtk::IterExprWireList* inputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_IterExprWireList"><code>wtk::IterExprWireList</code></a> for the input wires of this anonymous function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IterExprWireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">inputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprAnonFunction_instanceCount"><code>wtk::index_t instanceCount()</code></h5>
<div class="paragraph">
<p>Returns the number of instance values this anonymous function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">instanceCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprAnonFunction_shortWitnessCount"><code>wtk::index_t shortWitnessCount()</code></h5>
<div class="paragraph">
<p>Returns the number of short witness values this anonymous function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">shortWitnessCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprAnonFunction_body"><code>wtk::DirectiveList&lt;Number_T&gt;* body()</code></h5>
<div class="paragraph">
<p>returns the body of the anonymous function gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">body</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="IterExprAnonFunction_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the anonymous function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_ForLoop"><code>template&lt;typename Number_T&gt; struct ForLoop</code></h4>
<div class="paragraph">
<p>This represents a for-loop directive in the IR.</p>
</div>
<div class="sect4">
<h5 id="ForLoop_outputList"><code>wtk::WireList* outputList()</code></h5>
<div class="paragraph">
<p>Returns the output list of the <em>entire for-loop</em> (not to be confused with the output list of <em>one iteration of the for-loop</em>) as a <a href="#struct_WireList"><code>wtk::WireList</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">outputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_iterName"><code>char const* iterName()</code></h5>
<div class="paragraph">
<p>Returns the name of the loop&#8217;s iterator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">iterName</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_first"><code>wtk::index_t first()</code></h5>
<div class="paragraph">
<p>Returns the first iteration of the loop (inclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">first</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_last"><code>wtk::index_t last()</code></h5>
<div class="paragraph">
<p>Returns the last iteration of the loop (inclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">last</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_enum_BodyType"><code>enum BodyType</code></h5>
<div class="paragraph">
<p>An enumeration to indicate whether the loop&#8217;s body is named or anonymous.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::ForLoop&lt;Number_T&gt;::INVOKE</code></dt>
<dd>
<p>Named body (use <a href="#ForLoop_invokeBody"><code>this&#8594;invokeBody()</code></a> and <a href="#struct_IterExprFunctionInvoke"><code>wtk::IterExprFunctionInvoke</code></a>).</p>
</dd>
<dt class="hdlist1"><code>wtk::ForLoop&lt;Number_T&gt;::ANONYMOUS</code></dt>
<dd>
<p>Anonymous body (use <a href="#ForLoop_anonymousBody"><code>this&#8594;anonymousBody()</code></a> and <a href="#struct_IterExprAnonFunction"><code>wtk::IterExprAnonFunction&lt;Number_T&gt;</code></a>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_bodyType"><code>BodyType bodyType()</code></h5>
<div class="paragraph">
<p>Returns the body type of this for-loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">BodyType</span><span class="tok-w"> </span><span class="tok-nf">bodyType</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_invokeBody"><code>wtk::IterExprFunctionInvoke* invokeBody()</code></h5>
<div class="paragraph">
<p>Returns the body of this for-loop as an <a href="#struct_IterExprFunctionInvoke"><code>wtk::IterExprFunctionInvoke</code></a>.
If the loop&#8217;s body type is not <code><a href="#ForLoop_bodyType">this&#8594;bodyType()</a> == <a href="#ForLoop_enum_BodyType">wtk::ForLoop&lt;Number_T&gt;::INVOKE</a></code>, then undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">IterExprFunctionInvoke</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">invokeBody</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_anonymousBody"><code>wtk::IterExprAnonFunction&lt;Number_T&gt;* anonymousBody()</code></h5>
<div class="paragraph">
<p>Returns the body of this for-loop as an <a href="#struct_IterExprAnonFunction"><code>wtk::IterExprAnonFunction&lt;Number_T&gt;</code></a>.
If the loop&#8217;s body type is not <code><a href="#ForLoop_bodyType">this&#8594;bodyType()</a> == <a href="#ForLoop_enum_BodyType">wtk::ForLoop&lt;Number_T&gt;::ANONYMOUS</a></code>, then undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">IterExprAnonFunction</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">anonymousBody</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ForLoop_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the for-loop begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_CaseFunctionInvoke"><code>struct CaseFunctionInvoke</code></h4>
<div class="paragraph">
<p>The <code>wtk:CaseFunctionInvoke</code> invokes a function gate as the body of a switch-case.
It mirrors the form of <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a>, however, as the body of a switch-case, it is missing <code>outputList()</code>.</p>
</div>
<div class="sect4">
<h5 id="CaseFunctionInvoke_name"><code>char const* name()</code></h5>
<div class="paragraph">
<p>Returns the name of the function gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">name</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseFunctionInvoke_inputList"><code>wtk::WireList* inputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_WireList"><code>wtk::WireList</code></a> for the input wires of this invocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">inputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseFunctionInvoke_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the function invocation begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_CaseAnonFunction"><code>template&lt;typename Number_T&gt; struct CaseAnonFunction</code></h4>
<div class="paragraph">
<p>The <code>wtk:CaseAnonFunction</code> is the simultaneous declaration and invocation of an anonymous function-gate as the body of a switch-case.
It mirrors the structure of both <a href="#struct_FunctionDeclare"><code>wtk::FunctionDeclare&lt;Number_T&gt;</code></a> and <a href="#struct_FunctionInvoke"><code>wtk::FunctionInvoke</code></a>, although without certain attributes such as <code>name()</code> or, as the body of a switch-case,  <code>outputList()</code>.</p>
</div>
<div class="sect4">
<h5 id="CaseAnonFunction_inputList"><code>wtk::WireList* inputList()</code></h5>
<div class="paragraph">
<p>Returns a <a href="#struct_WireList"><code>wtk::WireList</code></a> for the input wires of this anonymous function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">inputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseAnonFunction_instanceCount"><code>wtk::index_t instanceCount()</code></h5>
<div class="paragraph">
<p>Returns the number of instance values this anonymous function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">instanceCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseAnonFunction_shortWitnessCount"><code>wtk::index_t shortWitnessCount()</code></h5>
<div class="paragraph">
<p>Returns the number of short witness values this anonymous function gate will consume.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">shortWitnessCount</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseAnonFunction_body"><code>wtk::DirectiveList&lt;Number_T&gt;* body()</code></h5>
<div class="paragraph">
<p>returns the body of the anonymous function gate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">DirectiveList</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">body</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseAnonFunction_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the anonymous function declaration begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_CaseBlock"><code>template&lt;typename Number_T&gt; struct CaseBlock</code></h4>
<div class="paragraph">
<p>This represents a case within a switch-statement.</p>
</div>
<div class="sect4">
<h5 id="CaseBlock_match"><code>Number_T match()</code></h5>
<div class="paragraph">
<p>Returns the field-literal which is matched against the switch-statement&#8217;s <a href="#SwitchStatement_condition"><code>condition()</code></a> wire to indicate if this case is active.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-nf">match</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseBlock_enum_BodyType"><code>enum BodyType</code></h5>
<div class="paragraph">
<p>An enumeration to indicate whether the case&#8217;s body is named or anonymous.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::CaseBlock&lt;Number_T&gt;::INVOKE</code></dt>
<dd>
<p>Named body (use <a href="#CaseBlock_invokeBody"><code>this&#8594;invokeBody()</code></a> and <a href="#struct_CaseFunctionInvoke"><code>wtk::CaseFunctionInvoke</code></a>).</p>
</dd>
<dt class="hdlist1"><code>wtk::CaseBlock&lt;Number_T&gt;::ANONYMOUS</code></dt>
<dd>
<p>Anonymous body (use <a href="#CaseBlock_anonymousBody"><code>this&#8594;anonymousBody()</code></a> and <a href="#struct_CaseAnonFunction"><code>wtk::CaseAnonFunction&lt;Number_T&gt;</code></a>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="CaseBlock_bodyType"><code>BodyType bodyType()</code></h5>
<div class="paragraph">
<p>Returns the body type of this case block.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">BodyType</span><span class="tok-w"> </span><span class="tok-nf">bodyType</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseBlock_invokeBody"><code>wtk::CaseFunctionInvoke* invokeBody()</code></h5>
<div class="paragraph">
<p>Returns the body of this case-block as a <a href="#struct_CaseFunctionInvoke"><code>wtk::CaseFunctionInvoke</code></a>.
If the case&#8217;s body type is not <code><a href="#CaseBlock_bodyType">this&#8594;bodyType()</a> == <a href="#CaseBlock_enum_BodyType">wtk::CaseBlock&lt;Number_T&gt;::INVOKE</a></code>, then undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">CaseFunctionInvoke</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">invokeBody</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseBlock_anonymousBody"><code>wtk::CaseAnonFunction&lt;Number_T&gt;* anonymousBody()</code></h5>
<div class="paragraph">
<p>Returns the body of this case-block as a <a href="#struct_CaseAnonFunction"><code>wtk::CaseAnonFunction&lt;Number_T&gt;</code></a>.
If the case&#8217;s body type is not <code><a href="#CaseBlock_bodyType">this&#8594;bodyType()</a> == <a href="#CaseBlock_enum_BodyType">wtk::CaseBlock&lt;Number_T&gt;::ANONYMOUS</a></code>, then undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">CaseAnonFunction</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">anonymousBody</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="CaseBlock_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the case-block begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_SwitchStatement"><code>template&lt;typename Number_T&gt; struct SwitchStatement</code></h4>
<div class="paragraph">
<p>This represents a switch-statement directive in the IR.</p>
</div>
<div class="sect4">
<h5 id="SwitchStatement_outputList"><code>wtk::WireList* outputList()</code></h5>
<div class="paragraph">
<p>Returns the switch-statement&#8217;s output list as a <a href="#struct_WireList"><code>wtk::WireList</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">WireList</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">outputList</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="SwitchStatement_condition"><code>wtk::index_t condition()</code></h5>
<div class="paragraph">
<p>Returns the condition (or "selector") wire of this switch-statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-nf">condition</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="SwitchStatement_size"><code>size_t size()</code></h5>
<div class="paragraph">
<p>Returns the number of cases in the switch-statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">size</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="SwitchStatement_caseBlock"><code>wtk::CaseBlock&lt;Number_T&gt;* caseBlock(size_t n)</code></h5>
<div class="paragraph">
<p>Returns the <code>n</code>th <a href="#struct_CaseBlock"><code>wtk::CaseBlock&lt;Number_T&gt;</code></a> in this switch-statement.
If <code>n</code> is outside of the range <code>n &gt;= 0 &amp;&amp; n &lt; <a href="#SwitchStatement_size">this&#8594;size()</a></code>, then undefined behavior occurs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-n">CaseBlock</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">caseBlock</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-n">n</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="SwitchStatement_lineNum()"><code>size_t lineNum()</code></h5>
<div class="paragraph">
<p>Returns the line number at which the switch-statement begins.
It may be unsupported by the parser (for example line numbering is nonsensical in a binary format), in which case <code>0</code> is always returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-nf">lineNum</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_IRParameters">IRParameters API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/Parser.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header defines some of the front-matter parameters of the IR.
Generally these parameters will be provided by the <a href="api/wtk/Parser.html#api_Parser">Parser API</a>.</p>
</div>
<div class="sect3">
<h4 id="enum_Resource"><code>enum class Resource</code></h4>
<div class="paragraph">
<p>An enumeration of the various resources an IR file may be.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wtk::Resource::relation</code></p>
</li>
<li>
<p><code>wtk::Resource::instance</code></p>
</li>
<li>
<p><code>wtk::Resource::shortWitness</code></p>
</li>
<li>
<p><code>wtk::Resource::invalid</code> (a default or error condition)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="struct_GateSet"><code>struct GateSet</code></h4>
<div class="paragraph">
<p>This structure defines the allowable gates of a relation.
It is split along two varieties of gates <code>arithmetic</code> or <code>boolean</code>, each of which may be taken as a "cannonical" set (e.g. all gates enabled) or a subset.</p>
</div>
<div class="sect4">
<h5 id="enum-gateset"><code>enum { &#8230;&#8203; } gateSet</code></h5>
<div class="paragraph">
<p>This indicates which variety of gates are used.
and has the following values</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wtk::GateSet::arithmetic</code></p>
</li>
<li>
<p><code>wtk::GateSet::boolean</code></p>
</li>
<li>
<p><code>wtk::GateSet::invalid</code> (a default or error conditions)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">enum</span><span class="tok-w"> </span><span class="tok-p">{</span>
<span class="tok-w">  </span><span class="tok-n">arithmetic</span><span class="tok-p">,</span>
<span class="tok-w">  </span><span class="tok-n">boolean</span><span class="tok-p">,</span>
<span class="tok-w">  </span><span class="tok-n">invalid</span>
<span class="tok-p">}</span><span class="tok-w"> </span><span class="tok-n">gateSet</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-n">invalid</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="subset-definitions-union">SubSet definitions (<code>union</code>)</h5>
<div class="paragraph">
<p>This unnamed <strong><code>union</code></strong> attribute defines sub sets of either of the gate set varieties.
As a union, only attributes of the active/correct gate set may be used.</p>
</div>
<div class="sect5">
<h6 id="arithmetic-subsets-struct">Arithmetic Subsets (<code>struct</code>)</h6>
<div class="paragraph">
<p>The following flags indicate if an arithmetic gate is allowable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bool enableAdd</code> indicates if <code>@add</code> is allowed.</p>
</li>
<li>
<p><code>bool enableAddC</code> indicates if <code>@addc</code> is allowed.</p>
</li>
<li>
<p><code>bool enableMul</code> indicates if <code>@mul</code> is allowed.</p>
</li>
<li>
<p><code>bool enableMulC</code> indicates if <code>@mulc</code> is allowed.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="boolean-subsets-struct">Boolean Subsets (<code>struct</code>)</h6>
<div class="paragraph">
<p>The following flags indicate if a boolean gate is allowable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bool enableXor</code> indicates if <code>@xor</code> is allowed.</p>
</li>
<li>
<p><code>bool enableAnd</code> indicates if <code>@and</code> is allowed.</p>
</li>
<li>
<p><code>bool enableNot</code> indicates if <code>@not</code> is allowed.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="bool-cannonical-const"><code>bool cannonical() const</code></h5>
<div class="paragraph">
<p>A "cannonical" gate set is one which has all gates of the variety enabled.
This function indicates if this GateSet is cannonical.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">cannonical</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="struct_FeatureToggles"><code>struct FeatureToggles</code></h4>
<div class="paragraph">
<p>The IR allows structural features to be disabled.
At the extremities "IR Simple" indicates that no features are enabled, while "IR Complete" indicates that all features are enabled.</p>
</div>
<div class="sect4">
<h5 id="bool-functiontoggle"><code>bool functionToggle</code></h5>
<div class="paragraph">
<p>This flag indicates that named functions are enabled, and that anonymous functions are allowed (except for the bodies of other enabled features).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-n">functionToggle</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-nb">false</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="bool-forlooptoggle"><code>bool forLoopToggle</code></h5>
<div class="paragraph">
<p>This flag indicates that for loops are enabled.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-n">forLoopToggle</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-nb">false</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="bool-switchcasetoggle"><code>bool switchCaseToggle</code></h5>
<div class="paragraph">
<p>This flag indicates that switch statements are enabled.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-n">switchCaseToggle</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-nb">false</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="bool-simple-const"><code>bool simple() const</code></h5>
<div class="paragraph">
<p>This method checks if these feature toggles form IR-Simple (all features disabled).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">simple</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="bool-complete-const"><code>bool complete() const</code></h5>
<div class="paragraph">
<p>This method checks if these feature toggles form IR-Complete (all features enabled).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">complete</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_ArithmeticStreamHandler">Arithmetic Stream Handler API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/ArithmeticStreamHandler.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This API is parameterized on a <code>Number_T</code> template.
<code>Number_T</code> should be integer-like enough to be parsed from a string.
This API is abstract and implemented by parsers for various IR formats.</p>
</div>
<div class="sect3">
<h4 id="class_ArithmeticStreamHandler"><code>template&lt;typename Number_T&gt; class ArithmeticStreamHandler</code></h4>
<div class="paragraph">
<p>The <code>wtk::ArithmeticStreamHandler&lt;Number_T&gt;</code> is a virtual class for the user to implement with callbacks for the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> to use when stream parsing.</p>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_setLineNumber"><code>virtual void setLineNumber(size_t const line)</code></h5>
<div class="paragraph">
<p>If the Parser supports line-numbering, it will use this callback to set the current line number before a gate&#8217;s callback is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">setLineNum</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">line</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleInstance"><code>virtual void handleInstance(wtk::index_t const idx)</code></h5>
<div class="paragraph">
<p>Called when an <code>@instance</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleInstance</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">idx</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleShortWitness"><code>virtual void handleShortWitness(wtk::index_t const idx)</code></h5>
<div class="paragraph">
<p>Called when an <code>@short_witness</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleShortWitness</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">idx</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleAdd"><code>virtual void handleAdd(wtk::index_t const out, wtk::index_t const left, wtk::index_t const right)</code></h5>
<div class="paragraph">
<p>Called when an <code>@add</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAdd</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleMul"><code>virtual void handleMul(wtk::index_t const out, wtk::index_t const left, wtk::index_t const right)</code></h5>
<div class="paragraph">
<p>Called when an <code>@mul</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleMul</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleAddC"><code>virtual void handleAddC(wtk::index_t const out, wtk::index_t const left, Number_T const right)</code></h5>
<div class="paragraph">
<p>Called when an <code>@addc</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAddC</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleMulC"><code>virtual void handleMulC(wtk::index_t const out, wtk::index_t const left, Number_T const right)</code></h5>
<div class="paragraph">
<p>Called when an <code>@mulc</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleMulC</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleAssign"><code>virtual void handleAssign(wtk::index_t const out, Number_T const val)</code></h5>
<div class="paragraph">
<p>Called when a constant assignment directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAssign</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">val</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleCopy"><code>virtual void handleCopy(wtk::index_t const out, wtk::index_t const in)</code></h5>
<div class="paragraph">
<p>Called when a copy directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleCopy</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">in</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleAssertZero"><code>virtual void handleAssertZero(wtk::index_t const in)</code></h5>
<div class="paragraph">
<p>Called when an <code>@assert_zero</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAssertZero</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">in</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleDeleteSingle"><code>virtual void handleDeleteSingle(wtk::index_t const in)</code></h5>
<div class="paragraph">
<p>Called when a <code>@delete</code> directive with a single argument is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleDeleteSingle</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">in</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleDeleteRange"><code>virtual void handleDeleteRange(wtk::index_t const first, wtk::index_t const last)</code></h5>
<div class="paragraph">
<p>Called when a <code>@delete</code> directive with a range argument is reached.
The range is inclusive on both ends.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleDeleteRange</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">first</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">last</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticStreamHandler_handleEnd"><code>virtual void handleEnd()</code></h5>
<div class="paragraph">
<p>Called after the last directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleEnd</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_BooleanStreamHandler">Boolean Stream Handler API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/BooleanStreamHandler.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="class_BooleanStreamHandler"><code>class BooleanStreamHandler</code></h4>
<div class="paragraph">
<p>The <code>wtk::BooleanStreamHandler</code> is a virtual class for the user to implement with callbacks for the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> to use when stream parsing.</p>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_setLineNumber"><code>virtual void setLineNumber(size_t const line)</code></h5>
<div class="paragraph">
<p>If the Parser supports line-numbering, it will use this callback to set the current line number before a gate&#8217;s callback is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">setLineNum</span><span class="tok-p">(</span><span class="tok-kt">size_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">line</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleInstance"><code>virtual void handleInstance(wtk::index_t const idx)</code></h5>
<div class="paragraph">
<p>Called when an <code>@instance</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleInstance</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">idx</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleShortWitness"><code>virtual void handleShortWitness(wtk::index_t const idx)</code></h5>
<div class="paragraph">
<p>Called when an <code>@short_witness</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleShortWitness</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">idx</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleXor"><code>virtual void handleXor(wtk::index_t const out, wtk::index_t const left, wtk::index_t const right)</code></h5>
<div class="paragraph">
<p>Called when an <code>@xor</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleXor</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleAnd"><code>virtual void handleAnd(wtk::index_t const out, wtk::index_t const left, wtk::index_t const right)</code></h5>
<div class="paragraph">
<p>Called when an <code>@and</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAnd</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleNot"><code>virtual void handleNot(wtk::index_t const out, wtk::index_t const in)</code></h5>
<div class="paragraph">
<p>Called when a <code>@not</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleNot</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">in</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleAssign"><code>virtual void handleAssign(wtk::index_t const out, uint8_t const val)</code></h5>
<div class="paragraph">
<p>Called when a constant assignment directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAssign</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint8_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">val</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleCopy"><code>virtual void handleCopy(wtk::index_t const out, wtk::index_t const in)</code></h5>
<div class="paragraph">
<p>Called when a copy directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleCopy</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">in</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleAssertZero"><code>virtual void handleAssertZero(wtk::index_t const in)</code></h5>
<div class="paragraph">
<p>Called when an <code>@assert_zero</code> directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleAssertZero</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">in</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleDeleteSingle"><code>virtual void handleDeleteSingle(wtk::index_t const in)</code></h5>
<div class="paragraph">
<p>Called when a <code>@delete</code> directive with a single argument is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleDeleteSingle</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">in</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleDeleteRange"><code>virtual void handleDeleteRange(wtk::index_t const first, wtk::index_t const last)</code></h5>
<div class="paragraph">
<p>Called when a <code>@delete</code> directive with a range argument is reached.
The range is inclusive on both ends.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleDeleteRange</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">first</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">last</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanStreamHandler_handleEnd"><code>virtual void handleEnd()</code></h5>
<div class="paragraph">
<p>Called after the last directive is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">handleEnd</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_antlr_Parser">ANTLR Parser API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/antlr/Parser.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespaces</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">antlr</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Parser API is parameterized on a <code>Number_T</code> template.
<code>Number_T</code> should be integer-like enough to be parsed from a string.
This API is abstract and implemented by parsers for various IR formats.</p>
</div>
<div class="sect3">
<h4 id="struct_antlr_Parser"><code>template&lt;typename Number_T&gt; struct Parser</code></h4>
<div class="paragraph">
<p>The <code>wtk::antlr::Parser&lt;Number_T&gt;</code> implements the <a href="api/wtk/Parser.html#struct_Parser"><code>wtk::Parser&lt;Number_T&gt;</code></a>.
It parses text and produces line numbering.
However, the <a href="https://www.antlr.org/">ANTLR</a> runtime has been known to use large quantities of memory.
Additionally, it cannot truly stream parse either IR-Simple or input streams (instance/short witness).
While, it does implement the <code>parseStream(&#8230;&#8203;)</code> API, it must read the entire relation ahead of time.</p>
</div>
<div class="sect4">
<h5 id="antlr_Parser_constructor_string"><code>Parser(std::string&amp; f_name)</code></h5>
<div class="paragraph">
<p>Constructor via opening the file named by <code>f_name</code>.
Undefined behavior occurs if the file does not exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Parser</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-o">&amp;</span><span class="tok-w"> </span><span class="tok-n">f_name</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_irregular_Parser">IRRegular Parser API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/irregular/Parser.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespaces</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">irregular</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Parser API is parameterized on a <code>Number_T</code> template.
<code>Number_T</code> should be integer-like enough to be parsed from a string.
This API is abstract and implemented by parsers for various IR formats.</p>
</div>
<div class="sect3">
<h4 id="struct_irregular_Parser"><code>template&lt;typename Number_T&gt; struct Parser</code></h4>
<div class="paragraph">
<p>The <code>wtk::irregular::Parser&lt;Number_T&gt;</code> implements the <a href="api/wtk/Parser.html#struct_Parser"><code>wtk::Parser&lt;Number_T&gt;</code></a>.
It parses text but does not produce line numbering.
It is designed to minimize memory usage while maximizing parser speed.
It is capable of stream-parsing, although it does require some buffering.</p>
</div>
<div class="sect4">
<h5 id="irregular_Parser_constructor_string"><code>Parser(std::string&amp; f_name)</code></h5>
<div class="paragraph">
<p>Constructor via opening the file named by <code>f_name</code>.
Undefined behavior occurs if the file does not exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Parser</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-o">&amp;</span><span class="tok-w"> </span><span class="tok-n">f_name</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="irregular_Parser_constructor_file"><code>Parser(FILE* f)</code></h5>
<div class="paragraph">
<p>Constructor which uses a <code>FILE*</code>.
Undefined behavior occurs if <code>f</code> is <code>nullptr</code> or <code>f</code> is not opened to an existing file (e.g. not a directory).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Parser</span><span class="tok-p">(</span><span class="tok-kt">FILE</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-n">f</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_flatbuffer_Parser">FlatBuffer Parser API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/flatbuffer/Parser.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespaces</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">flatbuffer</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Parser API is parameterized on a <code>Number_T</code> template.
<code>Number_T</code> should be integer-like enough to be parsed from a string.
This API is abstract and implemented by parsers for various IR formats.</p>
</div>
<div class="sect3">
<h4 id="struct_flatbuffer_Parser"><code>template&lt;typename Number_T&gt; struct Parser</code></h4>
<div class="paragraph">
<p>The <code>wtk::flatbuffer::Parser&lt;Number_T&gt;</code> implements the <a href="api/wtk/Parser.html#struct_Parser"><code>wtk::Parser&lt;Number_T&gt;</code></a>.
It parses binary and consequently line-numbering is nonsensical.
It cannot truly stream parse either IR-Simple or input streams (instance/short witness) because <a href="https://google.github.io/flatbuffers/">FlatBuffers</a> is designed around random access of a buffer.
While, it does implement the <code>parseStream(&#8230;&#8203;)</code> API, it must read the entire relation ahead of time.
It could (<em>but does not</em>) stream segments of a very large resource (<code>&gt;2GB</code>) because these resources are split into multiple FlatBuffers.</p>
</div>
<div class="sect4">
<h5 id="flatbuffer_Parser_constructor_string"><code>Parser(std::string&amp; f_name)</code></h5>
<div class="paragraph">
<p>Constructor via opening the file named by <code>f_name</code>.
Undefined behavior occurs if the file does not exist.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Parser</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-o">&amp;</span><span class="tok-w"> </span><span class="tok-n">f_name</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_bolt_Builder">BOLT Builder API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/bolt/Builder.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">bolt</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The BOLT API is parameterized on two templates.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Number_T</code></dt>
<dd>
<p>This template is the same integer-like template which the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> uses for numeric literals.</p>
</dd>
<dt class="hdlist1"><code>Wire_T</code></dt>
<dd>
<p>This template is an opaque structure supplied by the <a href="api/wtk/bolt/Backend.html#api_bolt_Backend">Backend</a> for encapsulating data related to a wire.
The Builder requires it to be default constructible/destructible, and the <a href="api/wtk/bolt/Evaluator.html#api_bolt_Evaluator">Evaluator</a> requires it be mutable/overwritable.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="struct_bolt_Builder"><code>template&lt;typename Wire_T, typename Number_T&gt; struct Builder</code></h4>
<div class="paragraph">
<p>The <code>wtk::bolt::Builder&lt;Wire_T, Number_T&gt;</code> conducts the first stage of BOLT invocation&#8201;&#8212;&#8201;building an augmented/annotated syntax tree.
It does its best to do this in <em>O(s)</em> time where <em>s</em> is the size of the syntax-tree.
This is easy to do for most of the IR, however, certain classes of for-loops require work proportional to either number of iterations ("soft" unrolling), or proportional to iterations and size of the sub-syntax tree ("hard" unrolling).</p>
</div>
<div class="sect4">
<h5 id="bolt_Builder_constructor"><code>Builder(Number_T const c)</code></h5>
<div class="paragraph">
<p>The only constructor for a <code>wtk::bolt::Builder&lt;Wire_T, Number_T&gt;</code> requires just a single <code>Number_T</code> parameter for the circuit&#8217;s <em>characteristic</em> (prime modulus).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Builder</span><span class="tok-p">(</span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">c</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="bolt_Builder_build"><code>Bolt&lt;Wire_T, Number_T&gt;* build(wtk::IRTree&lt;Number_T&gt;* const tree)</code></h5>
<div class="paragraph">
<p>This method builds a <code>wtk::bolt::Bolt&lt;Wire_T, Number_T&gt;</code> tree from the <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> parameter.
It returns <code>nullptr</code> when the <code>tree</code> violates IR well-formedness semantics.
In the case that <code>tree == nullptr</code> then undefined behavior occurs.
Multiple invocations of <code>build(&#8230;&#8203;)</code> on the same object will result in undefined behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Bolt</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-n">build</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">tree</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_bolt_Evaluator">BOLT Evaluator API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/bolt/Evaluator.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">bolt</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The BOLT API is parameterized on two templates.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Number_T</code></dt>
<dd>
<p>This template is the same integer-like template which the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> uses for numeric literals.</p>
</dd>
<dt class="hdlist1"><code>Wire_T</code></dt>
<dd>
<p>This template is an opaque structure supplied by the <a href="api/wtk/bolt/Backend.html#api_bolt_Backend">Backend</a> for encapsulating data related to a wire.
The <a href="api/wtk/bolt/Builder.html#api_bolt_Builder">Builder</a> requires it to be default constructible/destructible, and the Evaluator requires it be mutable/overwritable.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="class_Evaluator"><code>class Evaluator</code></h4>
<div class="paragraph">
<p>The <code>wtk::bolt::Evaluator&lt;Wire_T, Number_T&gt;</code> class encapsulates the second phase of BOLT invocation.
It traverses the BOLT relation and "executes" each gate.
Thus, it is by definition <em>O(n)</em> where <em>n</em> is the total number of gates.</p>
</div>
<div class="sect4">
<h5 id="Evaluator_constructor"><code>Evaluator(wtk::bolt::Backend&lt;Wire_T, Number_T&gt;* const b)</code></h5>
<div class="paragraph">
<p>The single constructor requires just a pointer to the <a href="api/wtk/bolt/Backend.html#api_bolt_Backend"><code>wtk::bolt::Backend&lt;Wire_T, Number_T&gt;</code> implementation</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Evaluator</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Backend</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">b</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Evaluator_evaluate"><code>bool evaluate(wtk::bolt::Bolt&lt;Wire_T, Number_T&gt;* const bolt, wtk::InputStream&lt;Number_T&gt;* const instance, wtk::InputStream&lt;Number_T&gt;* const witness)</code></h5>
<div class="paragraph">
<p>Evaluates a <code>wtk::bolt::Bolt&lt;Wire_T, Number_T&gt;</code> relation and returns <code>true</code> on success.
The bolt relation may be constructed using the <a href="api/wtk/bolt/Builder.html#api_bolt_Builder">BOLT Builder</a>.
It must also have two <a href="api/wtk/Parser.html#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;</code>s</a>.
The first, <code>instance</code>, must not be <code>nullptr</code>, while the second, <code>witness</code>, may be <code>nullptr</code> for the cases where the witness is inaccessible to a verifier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">evaluate</span><span class="tok-p">(</span><span class="tok-n">Bolt</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">bolt</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_bolt_Backend">BOLT Backend API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/bolt/Backend.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">bolt</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The BOLT API is parameterized on two templates.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Number_T</code></dt>
<dd>
<p>This template is the same integer-like template which the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> uses for numeric literals.</p>
</dd>
<dt class="hdlist1"><code>Wire_T</code></dt>
<dd>
<p>This template is an opaque structure supplied by the Backend for encapsulating data related to a wire.
The <a href="api/wtk/bolt/Builder.html#api_bolt_Builder">Builder</a> requires it to be default constructible/destructible, and the <a href="api/wtk/bolt/Evaluator.html#api_bolt_Evaluator">Evaluator</a> requires it be mutable/overwritable.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="class_Backend"><code>template&lt;typename Wire_T, typename Number_T&gt; class Backend</code></h4>
<div class="paragraph">
<p>An abstract class defining directives passed on to the ZK Backend.
A backend can implement this interface for BOLT to use during evaluation.
Each funciton is a handler for a different simple gate.</p>
</div>
<div class="paragraph">
<p>Wires are reported as <code>Wire_T</code> pointers, which are generally constructed ahead of time and reused, rather than allocated once.
BOLT does ensure that output pointer != input pointer, but multiple input pointers could be equal.</p>
</div>
<div class="paragraph">
<p>All handlers return <code>void</code>, and errors must be cached until the end of the relation when <a href="#Backend_check"><code>check()</code></a> is called by the user.</p>
</div>
<div class="sect4">
<h5 id="Backend_prime"><code>Number_T const prime</code></h5>
<div class="paragraph">
<p>This public attribute must be set by the <a href="#Backend_constructor">constructor</a> to the characteristic/prime modulus.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">prime</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_isBoolean"><code>bool const isBoolean</code></h5>
<div class="paragraph">
<p>This public attribute must be set by the <a href="#Backend_constructor">constructor</a> to <code>true</code> if the <a href="api/wtk/Parser.html#Parser_gateSet"><em>GateSet</em> is Boolean</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">prime</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_constructor"><code>Backend(Number_T const p, bool const ib)</code></h5>
<div class="paragraph">
<p>The <code>wtk::Backend&lt;Wire_T, Number_T&gt;</code> has only one constructor, with two parameters.
The first parameter, <code>p</code>, is the prime modulus or characteristic.
The second parameter, <code>ib</code>, is a flag indicating <code>true</code> when the<a href="api/wtk/Parser.html#Parser_gateSet"><em>GateSet</em></a> is Boolean and <code>false</code> when Arithmetic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Backend</span><span class="tok-p">(</span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">p</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">ib</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">:</span><span class="tok-w"> </span><span class="tok-n">prime</span><span class="tok-p">(</span><span class="tok-n">p</span><span class="tok-p">),</span><span class="tok-w"> </span><span class="tok-n">isBoolean</span><span class="tok-p">(</span><span class="tok-n">ib</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_addGate"><code>virtual void addGate(Wire_T* const out, Wire_T const* const left, Wire_T const* const right) = 0</code></h5>
<div class="paragraph">
<p>The backend must handle an addition.
<code>out</code> may be assumed to point to a different object from <code>left</code> or <code>right</code>.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">addGate</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_mulGate"><code>virtual void mulGate(Wire_T* const out, Wire_T const* const left, Wire_T const* const right) = 0</code></h5>
<div class="paragraph">
<p>The backend must handle a multiplication.
<code>out</code> may be assumed to point to a different object from <code>left</code> or <code>right</code>.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">mulGate</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_addcGate"><code>virtual void addcGate(Wire_T* const out, Wire_T const* const left, Number_T const right) = 0</code></h5>
<div class="paragraph">
<p>The backend must handle an addition with a constant.
<code>out</code> may be assumed to point to a different object from <code>left</code>.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">addcGate</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_mulcGate"><code>virtual void mulcGate(Wire_T* const out, Wire_T const* const left, Number_T const right) = 0</code></h5>
<div class="paragraph">
<p>The backend must handle a multiplication with a constant.
<code>out</code> may be assumed to point to a different object from <code>left</code>.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">addcGate</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_xorGate"><code>virtual void xorGate(Wire_T* const out, Wire_T const* const left, Wire_T const* const right) = 0</code></h5>
<div class="paragraph">
<p>The backend must handle an XOR.
<code>out</code> may be assumed to point to a different object from <code>left</code> or <code>right</code>.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">xorGate</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_andGate"><code>virtual void andGate(Wire_T* const out, Wire_T const* const left, Wire_T const* const right) = 0</code></h5>
<div class="paragraph">
<p>The backend must handle an AND.
<code>out</code> may be assumed to point to a different object from <code>left</code> or <code>right</code>.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">andGate</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">right</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_notGate"><code>virtual void notGate(Wire_T* const out, Wire_T const* const left) = 0</code></h5>
<div class="paragraph">
<p>The backend must handle an AND.
<code>out</code> may be assumed to point to a different object from <code>left</code>.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == true</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">notGate</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_copy"><code>virtual void copy(Wire_T* const out, Wire_T const* const left) = 0</code></h5>
<div class="paragraph">
<p>The backend must copy from <code>left</code> to <code>right</code>.
<code>out</code> may be assumed to point to a different object from <code>left</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">copy</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_assign"><code>virtual void assign(Wire_T* const out, Number_T const left) = 0</code></h5>
<div class="paragraph">
<p>The backend must assign <code>out</code> the constant value <code>left</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">assign</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_instance"><code>virtual void instance(Wire_T* const out, Number_T const left) = 0</code></h5>
<div class="paragraph">
<p>The backend must assign <code>out</code> the instance value <code>left</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">instance</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_witness"><code>virtual void witness(Wire_T* const out, Number_T const left) = 0</code></h5>
<div class="paragraph">
<p>The backend must assign <code>out</code> the witness value <code>left</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">witness</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">left</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_assertZero"><code>virtual void assertZero(Wire_T const* const wire) = 0</code></h5>
<div class="paragraph">
<p>The backend must check that <code>wire</code> is equal to <code>0</code>, and if this is not the case, a failure must be cached until <a href="#Backend_check"><code>this&#8594;check()</code></a> is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">assertZero</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">wire</span><span class="tok-p">)</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_caseSelect"><code>virtual void caseSelect(Wire_T* const selected_bit, Number_T const case_number, Wire_T const* const select_wire) = 0</code></h5>
<div class="paragraph">
<p>This function decides if a case is selected or active by comparison of the <code>select_wire</code> to the <code>case_number</code>.
If they are equal then <code>selected_bit</code> must be set to <code>1</code>, otherwise it must be set to <code>0</code>.</p>
</div>
<div class="paragraph">
<p>The default implementation uses exponentiation and <a href="https://en.wikipedia.org/wiki/Fermat&#8217;s_little_theorem">Fermat&#8217;s Little Theorem</a> to make the computation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">caseSelect</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">selected_bit</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">Number_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">case_number</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Wire_T</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">select_wire</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_multiplexHelper"><code>virtual void multiplexHelper(Wire_T* const out, std::vector&lt;LocalWireRange&lt;Wire_T, Number_T*&gt;* const dummies, std::vector&lt;Wire_T&gt; const* const selector_bits, wtk::index_t const dummy_place)</code></h5>
<div class="paragraph">
<p>Implements a multiplexer by summing a column of dummy wires conditionally on each selector bit.
This is repeated for each column of dummies.
This method is guaranteed only to be called if <code><a href="#Backend_isBoolean">this&#8594;isBoolean</a> == false</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>out</code></dt>
<dd>
<p>output wire (sum)</p>
</dd>
<dt class="hdlist1"><code>dummies</code></dt>
<dd>
<p>A rectangular matrix, although this method must access only the <code>dummy_place</code> column.</p>
</dd>
<dt class="hdlist1"><code>selector_bits</code></dt>
<dd>
<p>vector of condition bits, guaranteed to have the same length as the column.</p>
</dd>
<dt class="hdlist1"><code>dummy_place</code></dt>
<dd>
<p>the column to be summed</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Unfortunately, this method must expose the <code>wtk::bolt::LocalWireRange&lt;Wire_T, Number_T&gt;</code> internal structure.
The backend may call only the <code>deref(&#8230;&#8203;)</code> method (shown here) with <code>dummy_place</code> as the argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-nf">deref</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">idx</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a pseudo-ish code this function should implement:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><code>*out</code> := sum(<code>i</code>, <code>(*dummies)[i].deref(dummy_place)</code> * <code>(*selector_bits)[i]</code> );</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">multiplexHelper</span><span class="tok-p">(</span><span class="tok-n">Wire_T</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">out</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">vector</span><span class="tok-o">&lt;</span><span class="tok-n">LocalWireRange</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">dummies</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">vector</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-o">&gt;</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-o">*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">selector_bits</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">index_t</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">dummy_place</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_check"><code>virtual bool check() = 0</code></h5>
<div class="paragraph">
<p>This method is to be called by the caller (rather than the BOLT <a href="api/wtk/bolt/Builder.html#api_bolt_Builder">Builder</a> or <a href="api/wtk/bolt/Evaluator.html#api_bolt_Evaluator">Evaluator</a>.
After the Evaluator completes successfully, this function should be called to indicate if <em>evaluation validity</em> holds for the witnessed-statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">bool</span><span class="tok-w"> </span><span class="tok-nf">check</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-o">=</span><span class="tok-w"> </span><span class="tok-mi">0</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Backend_finish"><code>virtual void finish()</code></h5>
<div class="paragraph">
<p>This method is to be called by the caller (rather than the BOLT <a href="api/wtk/bolt/Builder.html#api_bolt_Builder">Builder</a> or <a href="api/wtk/bolt/Evaluator.html#api_bolt_Evaluator">Evaluator</a>.
After the Evaluator completes (successfully or not), this function must be called to perform cleanup tasks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">virtual</span><span class="tok-w"> </span><span class="tok-kt">void</span><span class="tok-w"> </span><span class="tok-nf">finish</span><span class="tok-p">()</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_bolt_PLASMASnooze">PLASMASnooze</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/bolt/PLASMASnooze.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">bolt</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The PLASMASnooze Interpreter is parameterized on two templates.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Number_T</code></dt>
<dd>
<p>This template is the same integer-like template which the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> uses for numeric literals.</p>
</dd>
<dt class="hdlist1"><code>Wire_T</code></dt>
<dd>
<p>This template is an opaque structure supplied by the <a href="api/wtk/bolt/Backend.html#api_bolt_Backend">Backend</a> for encapsulating data related to a wire.
PLASMASnooze requires the <code>Wire_T</code> to be default constructible/destructable as well as mutable/overwritable.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The PLASMASnooze API is an IR interpreter sharing the <a href="api/wtk/bolt/Backend.html#api_bolt-Backend">Backend API</a>.
It runs in a single pass and ignores certain deviations from the IR Specification, where they are deemed harmless.
The name PLASMASnooze is derived from <a href="tools/wtk-firealarm.html#tool-firealarm">FIREALARM</a>.
PLASMA is an improvement upon FIRE (in the sense of performance and pluggability of ZK Backends), while Snooze is the opposite of ALARM (in the sense of ignoring harmless deviations from the IR Spec).
The acryonym expands to <strong>P</strong>ractical <strong>L</strong>ocal <strong>A</strong>cceleration for <strong>S</strong>ingle-pass with <strong>M</strong>alleable <strong>A</strong>ssumtions <strong>Snooze</strong>.</p>
</div>
<div class="sect3">
<h4 id="class_PLASMASnooze"><code>template&lt;typename Wire_T, typename Number_T&gt; class PLASMASnooze</code></h4>
<div class="paragraph">
<p>The <code>wtk::bolt::PLASMASnooze&lt;Wire_T, Number_T&gt;</code> is a main driver object.
It walks an <a href="api/wtk/IRTree.html#api_IRTree">IR syntax tree</a> and, at each gate, invokes a corresponding gate handler from the <a href="api/wtk/bolt/Backend.html#api_bolt_Backend">Backend API</a>.</p>
</div>
<div class="sect4">
<h5 id="PLASMASnooze_constructor"><code>PLASMASnooze(wtk::bolt::Backend&lt;Wire_T, Number_T&gt;* const b)</code></h5>
<div class="paragraph">
<p>The constructor requires just a pointer to a <a href="api/wtk/bolt/Backend.html#class_Backend"><code>wtk::bolt::Backend&lt;Wire_T, Number_T&gt;</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">PLASMASnooze</span><span class="tok-p">(</span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Backend</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">b</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="PLASMASnooze_evaluate"><code>wtk::bolt::PLASMASnoozeStatus evaluate(wtk::IRTree&lt;Number_T&gt;* const rel_tree, wtk::InputStream&lt;Number_T&gt;* const ins_stream, wtk::InputStream&lt;Number_T&gt;* const wit_stream)</code></h5>
<div class="paragraph">
<p>Evaluates an <a href="api/wtk/IRTree.html#struct_IRTree"><code>wtk::IRTree&lt;Number_T&gt;</code></a> relation and returns an enum <a href="#enum_PLASMASnoozeStatus"><code>wtk::bolt::PLASMASnoozeStatus</code></a>.
It must also have two <a href="api/wtk/Parser.html#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;</code>s</a>.
The first, <code>instance</code>, must not be <code>nullptr</code>, while the second, <code>witness</code>, may be <code>nullptr</code> for the cases where the witness is inaccessible to a verifier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-w"> </span><span class="tok-nf">evaluate</span><span class="tok-p">(</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">IRTree</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">relation</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">instance</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">witness</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enum_PLASMASnoozeStatus"><code>enum class PLASMASnoozeStatus</code></h4>
<div class="paragraph">
<p>This is an enumeration of statuses that PLASMASnooze can return.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>wtk::bolt::PLASMASnooze::bad_relation</code></dt>
<dd>
<p>The relation is poorly-formed.</p>
</dd>
<dt class="hdlist1"><code>wtk::bolt::PLASMASnooze::bad_stream</code></dt>
<dd>
<p>The instance or witness is poorly-formed.</p>
</dd>
<dt class="hdlist1"><code>wtk::bolt::PLASMASnooze::well_formed</code></dt>
<dd>
<p>The relation, witness, and instance are all well-formed.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_bolt_ArithmeticPLASMASnoozeHandler">Arithmetic PLASMASnooze Streaming API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/bolt/ArithmeticPLASMASnoozeHandler.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">bolt</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The BOLT API is parameterized on two templates.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Number_T</code></dt>
<dd>
<p>This template is the same integer-like template which the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> uses for numeric literals.</p>
</dd>
<dt class="hdlist1"><code>Wire_T</code></dt>
<dd>
<p>This template is an opaque structure supplied by the Backend for encapsulating data related to a wire.
PLASMASnooze requires it to be default constructible/destructible, and mutable/overwritable.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="class_ArithmeticPLASMASnoozeHandler"><code>template&lt;template Wire_T, typename Number_T&gt; class ArithmeticPLASMASnoozeHandler</code></h4>
<div class="paragraph">
<p>The <code>wtk::bolt::ArithmeticPLASMASnoozeHandler&lt;Wire_T, Number_T&gt;</code> implements the <a href="api/wtk/ArithmeticStreamHandler.html#api_ArithmeticStreamHandler"><code>wtk::ArithmeticStreamHandler&lt;Number_T&gt;</code> abstract class</a> with callbacks for interpreting wire-numbers and making calls to the <a href="api/wtk/bolt/Backend.html#api_bolt_Backend"><code>wtk::bolt::Backend&lt;Wire_T, Number_T&gt;</code></a> callback API.</p>
</div>
<div class="sect4">
<h5 id="ArithmeticPLASMASnoozeHandler_constructor"><code>ArithmeticPLASMASnoozeHandler(wtk::bolt::Backend&lt;Wire_T, Number_T&gt;* const b, wtk::InputStream&lt;Number_T&gt;* const ins, wtk::InputStream&lt;Number_T&gt;* const wit)</code></h5>
<div class="paragraph">
<p>The constructor requires a <a href="api/wtk/bolt/Backend.html#api_bolt_Backend"><code>wtk::bolt::Backend&lt;Wire_T, Number_T&gt;*</code></a> for ZK callbacks, as well as two <a href="api/wtk/Parser.html#struct_InputStream"><code>wtk::InputStream&lt;Number_T&gt;*</code></a> parameters for the instance and short witness.
The second input stream (short witness) may be <code>nullptr</code>, as may be necessary for verifier implementations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">ArithmeticPLASMASnoozeHandler</span><span class="tok-p">(</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Backend</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">b</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">ins</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-n">Number_T</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">wit</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ArithmeticPLASMASnoozeHandler_check"><code>wtk::Bolt::PLASMASnoozeStatus check()</code></h5>
<div class="paragraph">
<p>After stream parsing/processing the <code>check()</code> method retrieves a status (<a href="api/wtk/bolt/PLASMASnooze.html#enum_PLASMASnoozeStatus"><code>wtk::PLASMASnoozeStatus</code></a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-w"> </span><span class="tok-nf">check</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api_bolt_BooleanPLASMASnoozeHandler">Boolean PLASMASnooze Streaming API</h3>
<div class="paragraph">
<p>Include this API as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-cp">#include</span><span class="tok-w"> </span><span class="tok-cpf">&lt;wtk/bolt/BooleanPLASMASnoozeHandler.h&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Members of this API live in the following namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">wtk</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-k">namespace</span><span class="tok-w"> </span><span class="tok-nn">bolt</span><span class="tok-w"> </span><span class="tok-p">{</span><span class="tok-w"> </span><span class="tok-p">...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The BOLT API is parameterized on two templates.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Number_T</code></dt>
<dd>
<p>This template is the same integer-like template which the <a href="api/wtk/Parser.html#api_Parser">Parser API</a> uses for numeric literals.
For Boolean relations, this is fixed to <code>uint8_t</code>.</p>
</dd>
<dt class="hdlist1"><code>Wire_T</code></dt>
<dd>
<p>This template is an opaque structure supplied by the Backend for encapsulating data related to a wire.
PLASMASnooze requires it to be default constructible/destructible, and mutable/overwritable.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="class_BooleanPLASMASnoozeHandler"><code>template&lt;template Wire_T, typename Number_T&gt; class BooleanPLASMASnoozeHandler</code></h4>
<div class="paragraph">
<p>The <code>wtk::bolt::BooleanPLASMASnoozeHandler&lt;Wire_T, Number_T&gt;</code> implements the <a href="api/wtk/BooleanStreamHandler.html#api_BooleanStreamHandler"><code>wtk::BooleanStreamHandler</code> abstract class</a> with callbacks for interpreting wire-numbers and making calls to the <a href="api/wtk/bolt/Backend.html#api_bolt_Backend"><code>wtk::bolt::Backend&lt;Wire_T, uint8_t&gt;</code></a> callback API.</p>
</div>
<div class="sect4">
<h5 id="BooleanPLASMASnoozeHandler_constructor"><code>BooleanPLASMASnoozeHandler(wtk::bolt::Backend&lt;Wire_T, uint8_t&gt;* const b, wtk::InputStream&lt;uint8_t&gt;* const ins, wtk::InputStream&lt;uint8_t&gt;* const wit)</code></h5>
<div class="paragraph">
<p>The constructor requires a <a href="api/wtk/bolt/Backend.html#api_bolt_Backend"><code>wtk::bolt::Backend&lt;Wire_T, uint8_t&gt;*</code></a> for ZK callbacks, as well as two <a href="api/wtk/Parser.html#struct_InputStream"><code>wtk::InputStream&lt;uint8_t&gt;*</code></a> parameters for the instance and short witness.
The second input stream (short witness) may be <code>nullptr</code>, as may be necessary for verifier implementations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">BooleanPLASMASnoozeHandler</span><span class="tok-p">(</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">Backend</span><span class="tok-o">&lt;</span><span class="tok-n">Wire_T</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">b</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">ins</span><span class="tok-p">,</span>
<span class="tok-w">    </span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">InputStream</span><span class="tok-o">&lt;</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;*</span><span class="tok-w"> </span><span class="tok-k">const</span><span class="tok-w"> </span><span class="tok-n">wit</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="BooleanPLASMASnoozeHandler_check"><code>wtk::Bolt::PLASMASnoozeStatus check()</code></h5>
<div class="paragraph">
<p>After stream parsing/processing the <code>check()</code> method retrieves a status (<a href="api/wtk/bolt/PLASMASnooze.html#enum_PLASMASnoozeStatus"><code>wtk::PLASMASnoozeStatus</code></a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c++"><span></span><span class="tok-n">wtk</span><span class="tok-o">::</span><span class="tok-n">bolt</span><span class="tok-o">::</span><span class="tok-n">PLASMASnoozeStatus</span><span class="tok-w"> </span><span class="tok-nf">check</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</main>

    <footer>
      
        <p id="distributionStatement">
          <strong>Distribution Statement A:</strong> Approved for Public Release, Distribution Unlimited.
        </p>
      
      <p>
        Copyright &copy; 2023, Stealth Software Technologies, Inc.
        All Rights Reserved.
      </p>
      
        <p id="acknowledgement">
          This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA) under Contract No. HR001120C0087. The views, opinions, and/or findings expressed are those of the author(s) and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.
        </p>
      

      <a href="https://www.stealthsoftwareinc.com" id="bottomLogoImg">
        <img
          src="/wiztoolkit/assets/icons/tetra-solid-400x100.png"
          alt="Stealth Software Technologies Home Page" /></a>

      
    </footer>
  </body>
</html>

